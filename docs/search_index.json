[["reg-expr.html", "Chapter 7 字符串与正则表达式 7.1 字符串编码方案 7.2 字符编码检测 7.3 字节 7.4 正则表达式 7.5 re模块", " Chapter 7 字符串与正则表达式 7.1 字符串编码方案 在计算机内部，字符都需要转换为对应的数字。这种转换规则（比如指定将 ‘A’ 转换为 65 ）就是“编码方案”。目前使用最广泛的基本编码方案是 ASCII 编码。该方案包含英文大小写字符、数字字符以及加减乘除等常用符号。 比较两个字符的大小，其实就是比较这两个字符的编码数字大小。所以在ASCII编码下，‘A’ &lt; ‘a’ ，因为二者的码值分别为 65 和 97 。同理，‘1’ &lt; ‘A’ 也是正确的，因为二者的码值分别是 49 和 65 。对两个字符串比较大小时，Python首先比较二者的第一位字符，如果能够分出大小，则停止比较并将其作为最终结果；而如果第一个字符相同，则比较第二个字符，如此逐位比较。假如在没有比较出结果时、其中一个字符串就已经结束，则判定这个比较短的字符串小于更长的另一个字符串。 使用 ord 函数可以获得一个字符的编码数字（基于当前默认编码方案），而使用 chr 函数则可以指定一个编码数字、并返回该编码所对应的字符。 ASCII 表中位于 0~31 之间的字符，都是用于控制文本格式或针对计算机通讯等操作发出特殊指令，所以无法像普通文字一样显示在屏幕上。因此这些字符被称为“控制字符”、“非打印字符”或“不可显示字符”。其中10号字符（换行）最为常用。在 Dos 和 Windows 系统中，习惯上将 13 号字符（回车）和 10 号字符（换行）放在一起，共同表示一次换行。而在 Linux、Unix 以及 Mac OS 等系统中，则只使用 10 号字符表示换行。尽管如此，只使用 10 号字符换行的文本文件也能被大多数 Windows 下的编辑器正常读取。 为了在字符串中表示一些特殊字符（比如换行），Python 定义了一些 “转义字符”，即使用反斜线  和若干个特定字符组合在一起，表达一个含义。比如使用 代表换行。如果需要在字符串中表示引号，可以将其写为转义字符 ' 或 \" ，以免与最外层表示字符串起止的引号混淆。如果需要在字符串中表示反斜线  ，可以使用转义字符 \\ ，从而将反斜线的 “转义标识符” 功能转变为 “普通反斜线” 。 标准ASCII编码中使用一个字节保存一个字符，而一个字节（8位二进制）只能容纳256个数字，所以无法为中文等语言文字提供编码。 对于无法使用 ASC 编码的语言，相关国家的标准组织分别提出了自己的扩展编码方案，使用多个字节保存一个字符。典型如中国的 GB 系列、日本的 Shift-JIS 等。GB系列编码的最新版本是 GB18030，完全兼容 GB2312 并基本兼容 GBK。所以在不得不使用 GB2312 的场合，建议尽量使用 GB18030 代替它（除非所使用的操作系统等软件不支持GB18030）。 7.2 字符编码检测 如果我们知道一个文本文件的编码方案，我们可以指定读取的’encoding’选项直接读取： with open(&#39;jp_str.txt&#39;, &#39;r&#39; , encoding= &#39;UTF-8&#39;) as f: b = f.readlines() print(b) ## [&#39;あのねせかいはじつはつながっているんだって\\n&#39;, &#39;だからたとえはなれてしまってもみんなひとりじゃない\\n&#39;, &#39;たいせつなひととはいつまでもずっとどこかでつながっているのさ&#39;] 如果不知道这个文件的编码方案，可能会遇到乱码或读取错误的问题。第三方模块 chardet 可以自动检测字符编码的类型。使用过程如下： 1. 使用 open(文件名, ‘rb’ ) 以二进制方式打开文件； 2. 使用 b = f.read() 将文件内容全部读入字节流对象 b； 3. 使用 chardet.detect( b ) 可以得到一个字典，其中键 ‘encoding’ 对应的值就是 chardet 猜测的编码名称，‘confidence’ 键对应的是该猜测的可靠程度（置信度）。 应用样例如下： import chardet with open(&#39;jp_str.txt&#39;, &#39;rb&#39;) as f: b = f.read() e = chardet.detect(b) print(e) s = b.decode(e.get(&#39;encoding&#39;)) print(s) ## {&#39;encoding&#39;: &#39;utf-8&#39;, &#39;confidence&#39;: 0.99, &#39;language&#39;: &#39;&#39;} ## あのねせかいはじつはつながっているんだって ## だからたとえはなれてしまってもみんなひとりじゃない ## たいせつなひととはいつまでもずっとどこかでつながっているのさ 如果想让 chardet 判断出某段文本数据的编码名称，必须将该文本的原始二进制形式（即字节流）交给chardet的detect 方法，以便其观察数值特征和统计分析。在 Python 中，存储原始字节信息需要使用 bytes 对象。当使用 open(文件名, ‘r’) 读取文件时，Python会自动按照操作系统当前的默认编码方案、将硬盘上该文件的二进制数据解码为字符串，因而并没有得到其原始的字节数值、无法交给 chardet 进行检测。所以需要使用 open(文件名, ‘rb’) 的方式，指定以二进制方式读取文件，不经过自动编码转换。 如果将 open 函数的读写模式参数指定为 ‘rb’ 或 ‘wb’ ，则代表 “二进制读写” ，不会经过自动编码转换。此时不能再使用 f.readline() 方法读取文件内容，而应使用 b=f.read() 或 f.write(b) 方法。前者可以将文件全部内容的原始字节数值读入到一个 bytes 对象，后者则可以将一个 bytes 对象中的全部字节写入文件。此外，也可以通过 b=f.read(5) 的形式，指定从文件中只读取 5 个字节放入 b 。 bytes对象是一种由整数构成的序列（Sequence），因而与列表、字符串具有相似的用法，都可以使用下标和切片形式访问、使用 for 循环遍历。如果直接用 print 将 bytes 对象打印在屏幕上，Python则会自动将其中的所有数据以16进制数字字符串（如 ）的形式显示，以方便阅读。 7.3 字节 字节（bytes）是一种比特流，它的存在形式是01010001110这种01组合。它必须有一个编码方式，使得它变成有意义的比特流，而不是一堆晦涩难懂的数字。 bytes只负责以字节序列的形式（二进制形式）来存储数据，至于这些数据到底表示什么内容（字符串、数字、图片、音频等），完全由程序的解析方式决定。如果采用合适的字符编码方式（字符集），字节串可以恢复成字符串；反之亦然，字符串也可以转换成字节串。bytes 类型的数据非常适合在互联网上传输，可以用于网络通信编程；bytes 也可以用来存储图片、音频、视频等二进制格式的文件。 字符串和 bytes 存在着千丝万缕的联系。字符串类有一个encode()方法，它是从字符串向比特流的编码过程；反之，bytes类恰好有个decode()方法，它是从比特流向字符串解码的过程。 a = &quot;中文&quot; b = a.encode(encoding = &#39;UTF-8&#39;) b.decode(encoding = &#39;UTF-8&#39;) ## &#39;中文&#39; 或者： b = bytes(a, encoding = &#39;UTF-8&#39;) type(b) ## &lt;class &#39;bytes&#39;&gt; str(b, encoding = &#39;UTF-8&#39;) ## &#39;中文&#39; 对于任何来源的文本数据（文本文件、网络网页、数据库 ……），如果发现乱码，都可以用下面的思路解决： 使用字节流方式读取该来源，比如 open(文件名,‘rb’) ，将原始字节数据存入一个bytes对象； 将该 bytes 对象交给 chardet 等工具，获取最可能的编码名称； 调用该 bytes 对象的 decode 方法，按照获取的编码名称将其转换为字符串显示。 7.4 正则表达式 正则表达式可以被看作一种 “描述语言” 的语言。通过正则表达式，我们可以定义一个“规则”或“模式”，然后在文本中匹配所有符合该规则的字符串。 7.4.1 定位符 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，‘n’ 匹配字符 “n”。‘’ 匹配一个换行符。序列 ‘\\\\’ 匹配 “\\” 而 “\\(” 则匹配 “(”。 ^ 匹配输入字符串的开始位置。如果设置了 Multiline 修饰符，^ 也匹配 ‘’ 或 ’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了 Multiline 修饰符，$ 也匹配 ‘’ 或 ’ 之前的位置。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er 可以匹配”never” 中的 ’er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。‘er’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\A 匹配字符串的开始位置，与^不同，它不会被Multiline 修饰符影响 \\Z 匹配字符串的结束位置，与$不同，它不会被Multiline 修饰符影响 \\z 匹配字符串的结束位置，与$不同，它不会被Multiline 修饰符影响；与，如果字符后面有空行，它不会匹配空行前的任何内容，即它仅匹配全文最后一个字符 7.4.2 字符组 字符 描述 x|y 匹配 x 或 y。例如，‘z|food’ 能匹配 “z” 或 “food”。‘(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、‘l’、‘i’、‘n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，‘[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，‘[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 [[:alpha:]] 任何字母 [[:digit:]] 任何数字 [[:alnum:]] 任何字母和数字 [[:space:]] 任何空白字符 [[:upper:]] 任何大写字母 [[:lower:]] 任何小写字母 [[:punct:]] 任何标点符号 [[:xdigit:]] 任何16进制的数字，相当于[0-9a-fA-F] 7.4.3 量词 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。*** 等价于{0,}**。 + 匹配前面的子表达式一次或多次。例如，‘zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，“do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，‘o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，‘o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。‘o{1,}’ 等价于 ‘o+’。‘o{0,}’ 则等价于 ’o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，“o{1,3}” 将匹配 “fooooood” 中的前三个 o。‘o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是懒惰的。懒惰模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，‘o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（、之外的任何单个字符。要匹配包括 ‘’ 在内的任何字符，请使用像”(.|)“的模式。 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，‘n’ 匹配字符 “n”。‘’ 匹配一个换行符。序列 ‘\\\\’ 匹配 “\\” 而 “\\(” 则匹配 “(”。 import re s2 = &quot;《三体》第二部《黑暗森林》作者&quot; x = re.findall(&#39;《.*?》&#39;, s2) print(x) ## [&#39;《三体》&#39;, &#39;《黑暗森林》&#39;] 7.4.4 捕获组 字符 描述 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到。要匹配圆括号字符，请使用 ‘\\(’ 或 ‘\\)’。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ’industry|industries’ 更简略的表达式。 (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，“Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)“能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?&lt;=95|98|NT|2000)Windows”能匹配”2000Windows”中的”Windows”，但不能匹配”3.1Windows”中的”Windows”。 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”(?&lt;!95|98|NT|2000)Windows”能匹配”3.1Windows”中的”Windows”，但不能匹配”2000Windows”中的”Windows”。 s1 = &#39;123abc456dfg&#39; x = re.findall(&quot;([1-9])([a-z]+)&quot;, s1) print(x) ## [(&#39;3&#39;, &#39;abc&#39;), (&#39;6&#39;, &#39;dfg&#39;)] import re s1 = &#39;&#39;&#39;第一回 第二回 第三回 第四回五回 &#39;&#39;&#39; x = re.findall(&quot;第(.?)回&quot;, s1) print(x) ## [&#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;] 7.4.5 元字符 字符 描述 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [\\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [\\^\\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \\num 匹配 num，其中 num 是一个正整数。对前面所获取的匹配的引用。例如，‘(.)\\1’ 匹配两个连续的相同字符。 \\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，‘\\x41’ 匹配 “A”。‘\\x041’ 则等价于 ‘\\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 7.5 re模块 函数 解释 re.match re.match(pattern, string, flags=0)；re.match 尝试从字符串的起始位置匹配一个模式，匹配成功返回一个匹配的对象，否则返回 None。 re.search re.search函数会在字符串内查找模式匹配，只到找到第一个匹配然后返回，参数与返回与re.match完全一致。 re.findall 返回列表，找不到则返回空列表 re.compile 用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。 re.sub 用于替换字符串中的匹配项，re.sub(pattern, repl, string, count=0, flags=0) ；repl : 替换的字符串，也可是一个函数。 flags是匹配模式修饰符，见下表： 修饰符 描述 re.I 使匹配对大小写不敏感 re.L 做本地化识别（locale-aware）匹配 re.M 多行匹配，影响 ^ 和 $ re.S 使. 匹配包括换行在内的所有字符 re.U 根据Unicode字符集解析字符。这个标志影响 \\w, \\W, \\b, \\B. re.X 这个选项忽略空格和 # 后面的注释，以便把规则写得更易于理解。 可以使用 group(num) 或 groups() 匹配对象函数来获取匹配表达式。 import re msg = &#39;name:Alice,age:6&#39; obj = re.search(&#39;name:(\\w+),age:(\\d+)&#39;, msg) print(obj.group(0)) # name:Alice,age:6 原始字符 ## name:Alice,age:6 print(obj.group(1)) # Alice 第一个匹配 ## Alice print(obj.group(2)) # 6 第二个匹配 ## 6 print(obj.groups()) # (&#39;Alice&#39;, &#39;6&#39;) ## (&#39;Alice&#39;, &#39;6&#39;) 7.5.1 例子 re.sub 字符串替换： txt = &#39;1A2B3C&#39; re.sub(r&#39;\\D&#39;, &quot;-&quot;, txt) # 将非数字转换为- ## &#39;1-2-3-&#39; re.sub(r&#39;\\D&#39;, &quot;&quot;, txt) # 删除非数字 ## &#39;123&#39; re.sub(r&#39;(\\d)&#39;, lambda x : str(2*int(x.group())), txt) # 数字乘以2 ## &#39;2A4B6C&#39; '(.)\\\\1+'：匹配任意字符的一次或多次重复出现。 txt = &#39;1123aa&#39; re.findall(&#39;(.)\\\\1+&#39;, txt) ## [&#39;1&#39;, &#39;a&#39;] re.findall(r&#39;(.)\\1+&#39;, txt) ## [&#39;1&#39;, &#39;a&#39;] '^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[,._]).{8,}$'：检查给定字符串是否为强密码，必须同时包含英语字母大写字母、英文小写字母、数字或特殊符号（如英文逗号、英文句号、下划线），并且长度必须至少8位。 txt = &#39;123abCD,&#39; rex = r&#39;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[,._]).{8,}$&#39; x = re.match(rex, txt) print(x) ## &lt;re.Match object; span=(0, 8), match=&#39;123abCD,&#39;&gt; 或者 pattern = re.compile(rex) x = pattern.match(txt) print(x) ## &lt;re.Match object; span=(0, 8), match=&#39;123abCD,&#39;&gt; Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$ 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 7.5.2 参考材料 正则表达式模式在线图示网站：https://regexper.com/ 正则表达式详语法：https://www.runoob.com/regexp/regexp-syntax.html 在线测试工具：https://regex101.com/ 在线测试工具：https://c.runoob.com/front-end/854/ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
