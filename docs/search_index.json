[["built-in-type2.html", "Chapter 4 内置数据类型（二） 4.1 列表list 4.2 元组tuple 4.3 字典dict 4.4 集合set 4.5 数据类型判断", " Chapter 4 内置数据类型（二） 4.1 列表list list是Python内置的一种数据类型，list是一个可变的有序表，可以随时添加和删除其中的元素。比如，列出班里所有同学的名字，就可以用一个list表示： x = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;] list里面的元素的数据类型可以不同， l = [&#39;Apple&#39;, 123, True] # list的元素也可以是另一个list s = [&#39;python&#39;, &#39;java&#39;, [&#39;asp&#39;, &#39;php&#39;], &#39;scheme&#39;] 4.1.1 索引和切片 用len()函数可以计算list中元素的个数。用索引可以访问list中每一个位置的元素，索引是从0开始的，最后一个元素的索引是len(x) - 1 。可以用-1做索引直接获取最后一个元素，用-2做索引可以直接获取倒数第二个元素。 len(x) ## 3 x[-2];x[1] ## &#39;Bob&#39; ## &#39;Bob&#39; #切片 s = [1,2,3,4,5,6] s[1:3]; s[-2:] ## [2, 3] ## [5, 6] 4.1.2 列表修改 list是可变对象，可以使用下列函数对列表中的元素进行修改。 x.append(&#39;Adam&#39;) # 可以往list中追加元素到末尾 # 也可以把元素插入到指定的位置 x.insert(1, &#39;Jack&#39;) # 可以用pop()方法删除list中的元素 x.pop(2) ## &#39;Bob&#39; # 可以直接赋值给对应的索引位置 x[1] = &#39;Sarah&#39; # 用in可以检查列表是否包含某个值 &#39;Sarah&#39; in x ## True 4.1.3 列表排序 List的sort()方法可以对原列表进行排序，如果列表中的数据类型不同则会报错。 x.sort() x.reverse() # 反转列表中元素 print(x) ## [&#39;Tracy&#39;, &#39;Sarah&#39;, &#39;Michael&#39;, &#39;Adam&#39;] x = [&#39;a&#39;,1,&#39;b&#39;,2,] x.sort() # list 和 str 不能相互比较 4.1.4 列表复制 copy() 函数用于复制列表，等同于 a[:]。 y = x.copy() arr = [{&#39;name&#39;: &#39;wcl&#39;, &#39;age&#39;: 23}, {&#39;name&#39;: &#39;wjy&#39;, &#39;age&#39;: 14}] arr2 = arr.copy() del arr[1] arr[0][&#39;age&#39;] = 18 print(&#39;arr：&#39;, arr) ## arr： [{&#39;name&#39;: &#39;wcl&#39;, &#39;age&#39;: 18}] print(&#39;arr2：&#39;, arr2) ## arr2： [{&#39;name&#39;: &#39;wcl&#39;, &#39;age&#39;: 18}, {&#39;name&#39;: &#39;wjy&#39;, &#39;age&#39;: 14}] 可以看出，copy() 只是是浅度复制，修改列表不会互相影响，但是修改列表里面的对象会影响到对方列表里面对象。 4.2 元组tuple 另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。元组使用小括号()，列表使用方括号[]。 names = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;) tup = &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; # 不需要括号也可以 tuple没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用names[0]，names[-1]，但不能赋值成另外的元素。不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 只有1个元素的tuple定义时必须加一个逗号,，来消除歧义 t = (1,); t ## (1,) 可以用加号运算符将元组串联起来： (4, None, &#39;foo&#39;) + (6, 0) + (&#39;bar&#39;,) ## (4, None, &#39;foo&#39;, 6, 0, &#39;bar&#39;) 可以用切片的方式更新元组： T = (&#39;aa&#39;,&#39;bb&#39;,&#39;cc&#39;,&#39;dd&#39;,&#39;ee&#39;) T = T[0:4]+T[4:] # T = T[0:4]+T[4] 会报错 print(T) ## (&#39;aa&#39;, &#39;bb&#39;, &#39;cc&#39;, &#39;dd&#39;, &#39;ee&#39;) 元组对象的“不可变性”，是指元组内部保存的各个地址号码不允许修改；但是这些号码所指向的内存单元中如果是可变对象（比如列表），那么这些可变对象仍可随意修改，与元组无关。 4.3 字典dict Python内置了字典（dict），dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。 d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85} d[&#39;Michael&#39;] ## 95 给定一个名字，比如'Michael'，dict在内部就可以直接计算出Michael对应的存放成绩的”页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。 # 把数据放入dict，除了初始化时指定外，还可以通过key放入 d[&#39;Adam&#39;] = 67 # dict可以接受2元元组的列表 mapdict = dict(zip(range(5), reversed(range(5)))) del mapdict[0] # 等同于 mapdict.pop(0) print(mapdict) ## {1: 3, 2: 2, 3: 1, 4: 0} 字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的。但是键（key)则有明确的限制：首先是不重复，创建时如果同一个键被赋值两次，只有后一个值会被记住；其次是不可变，dict的key必须是不可变对象，只能用用数字，字符串或元组充当。 dict内部存放的顺序和key放入的顺序是没有关系的。和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict是“以空间换时间”的数据结构，即在内存中事先存储好所有键值对，从而在查询时可以直接依据键找到值、节省检索时间。dict可以用在需要高速查找的地方。 4.3.1 字典操作 dict.keys(), dict.values() 和 dict.items() 返回的对象是视图对象。它们提供了字典条目的动态视图，这意味着当字典发生变化时，视图会反映这些变化。他们返回的都是可迭代对象。dict.keys()返回字典所有的键；dict.values()返回该字典所有的值； dict.items() 返回字典所有的键值对(key, value)。使用 for k in dict循环遍历字典元素时，每次循环的变量 k 都是字典中的键。键视图类似集合，因为key是唯一且可散列的（hashable）。 dic = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3,} for i in dic: print(i) ## a ## b ## c for i in dic.values(): print(i) ## 1 ## 2 ## 3 字典可以通过以下方法调换 key和 value，当然要注意原始 value 的类型,必须是不可变类型： reverse = {v: k for k, v in dic.items()} print(reverse) ## {1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;} 通过 values 取到 key 的方法： dic={&quot;a&quot;:5,&quot;b&quot;:3,&quot;c&quot;:1} list(dic.keys())[list(dic.values()).index(3)] ## &#39;b&#39; 4.3.2 fromkeys() fromkeys()是字典类型的方法，所以必须先有一个字典对象，再调用该对象的fromkeys方法。常用写法为 d={}.fromkeys(a, x) （或者d=dict.fromkeys(a, x)），即将 a 中每一个元素都作为键，对应的值统一为x，从而构建一个新字典，并将该字典返回给变量 d 。 使用 fromkeys() 时必须注意以下常见问题： - d.fromkeys(a) 并不会修改 d ，而是建立一个新字典，而且新字典中的内容也完全不受 d 中已有元素的影响； - 假如 a 中某个元素也是一个容器，那么该容器整体被作为一个键，而不是拆分成键值对； - 通过 d = {}.fromkeys(a,x) 创建的新字典 d ，其中所有元素的值都指向同一个内存地址即 x ，因此“一改全改”。 - d = {}.fromkeys(a,b) 中，即使 a 和 b 都是列表，也不会将这两个列表合并为一个字典，而是会让新字典 d 中所有键都指向同一个列表 b 。 {}.fromkeys([1,2,3], [2,3,4]) # 等价于dict.fromkeys([1,2,3], [2,3,4]) ## {1: [2, 3, 4], 2: [2, 3, 4], 3: [2, 3, 4]} 4.4 集合set set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以在set中没有重复的key。集合类型有以下特点和要求： - 禁止出现重复元素； - 不能指定元素的顺序，不像列表那样按照添加的先后顺序排列； - 只能使用不可变对象（数字、逻辑值、元组、字符串等）作为元素。 创建集合时必须传入可迭代对象。可以使用 set() 将列表、元组、字典，以及 range、zip 等可迭代对象转换为集合。转换过程中，原列表等容器里的重复元素会被自动删除。如果将字典转换为集合，得到的集合是由字典中所有元素的键构成、不包含值。空集合的表示方法为 set() ，而不是 {} 。后者代表空的字典对象。 set([1, 2, 3]) ## {1, 2, 3} 注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这三个元素，显示的顺序也不表示set是有序的。重复元素在set中自动被过滤： s = set([1, 1, 2, 2, 3, 3]) s.add(4)可以添加元素到set中；s.update(x)也可以添加元素，且参数可以是列表，元组，字典等。 s.update({5,3}) print(s) ## {1, 2, 3, 5} s.remove(4)可以删除元素，s.discard(x)也是移除集合中的元素，且如果元素不存在，不会发生错误。 注意当集合只有一个元素时的创建方法： set(&quot;Hello&quot;) ## {&#39;H&#39;, &#39;l&#39;, &#39;o&#39;, &#39;e&#39;} set((&quot;Hello&quot;,)) ## {&#39;Hello&#39;} set(123) # TypeError: &#39;int&#39; object is not iterable 4.4.1 集合运算 set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作： s1 = set([1, 2, 3]) s2 = set([2, 3, 4]) s1 &amp; s2 # 交 ## {2, 3} s1 | s2 # 并 ## {1, 2, 3, 4} s1 - s2 # 差 ## {1} s1 ^ s2 # 两个集合中不重复的元素集合 ## {1, 4} 4.5 数据类型判断 使用 type(x) 可以得到一个type类对象，该对象的属性中保存了名称 x 的数据类型信息。特别是该对象的 __name__ 属性，就是变量 x 的类型名称。比如 type(3.14).__name__ 得到的就是字符串 ‘float’ 。由于 type 函数将类型名称作为字符串返回，所以实际编程时容易因为字符串笔误等原因造成隐患；同时该函数无法用于分辨一个类型是否属于其父类（比如bool类型数据True是否也是一个int类型的数据），因此一般更推荐使用 isinstance 函数。 isinstance(x, 类型名) 可以返回一个逻辑值True或False，代表x是否属于指定类型。其中类型名不是字符串形式，而是直接书写，比如 isinstance(x, int) 。 x = 1 isinstance(x, int) ## True 4.5.1 可变与不可变 Python中的大多数对象，比如列表、字典、集合、NumPy数组、用户定义的类，都是可变的。这意味着这些对象或包含的值可以被修改。其它的，比如数字、字符串和元组，是不可变的： a_tuple = (3, 5, (4, 5)) a_tuple[1] = &#39;four&#39; #TypeError 4.5.2 hashable 官方文档对hashable的说明： 一个对象的哈希值如果在其生命周期内绝不改变，就被称为 可哈希 （它需要具有 __hash__() 方法），并可以同其他对象进行比较（它需要具有 __eq__() 方法）。可哈希对象必须具有相同的哈希值比较结果才会相同。 可哈希性使得对象能够作为字典键或集合成员使用，因为这些数据结构要在内部使用哈希值。 大多数 Python 中的不可变内置对象都是可哈希的；可变容器（例如列表或字典）都不可哈希；不可变容器（例如元组和 frozenset）仅当它们的元素均为可哈希时才是可哈希的。 用户定义类的实例对象默认是可哈希的。 它们在比较时一定不相同（除非是与自己比较），它们的哈希值的生成是基于它们的 id()。 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
