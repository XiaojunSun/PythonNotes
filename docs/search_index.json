[["index.html", "我的Python笔记 前言", " 我的Python笔记 Xiaojun Sun 2021-12-13 前言 这是写给自己看的Python学习笔记。从 Xie (2016) 了解到在RStudio中可以很方便地编写gitbook，很适合组织知识和想法，比传统的blog更便于书写和阅读，所以开始以这种形式编写Python学习笔记。希望可以坚持下去！ 本书的网页版在Github上面：https://xiaojunsun.github.io/PythonNotes/。 我参考了以下优秀的Python学习资料： Python 3 教程 | 菜鸟教程 Python 官方文档 Python Cookbook 使用到的编辑工具有： Visual Studio Code Rstudio Markdown表格工具 本书在Visual Studio Code中使用RMarkdown格式编写1。 References "],["build-env.html", "Chapter 1 搭建Python运行环境 1.1 安装Anaconda 1.2 环境管理 1.3 包的管理 1.4 Jupyter Notebook 1.5 IPython简介 1.6 PyCharm 1.7 语法基础", " Chapter 1 搭建Python运行环境 1.1 安装Anaconda 推荐使用Anaconda安装Python运行环境，在国内推荐清华大学开源软件镜像站进行下载。安装时注意Anaconda的安装路径不要出现空格。Anaconda安装成功之后，我们需要修改其包管理镜像为国内源。打开Anaconda Prompt，输入： conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes 1.2 环境管理 Anaconda自带的conda是包和环境的管理工具，适用于Python，R，Ruby等语言；pip则是Python自带的Python包管理器。一般推荐使用conda进行包和环境的管理。在Anaconda中Python的不同版本可以共存，使用conda可以创建当前环境（base）以外的新环境，如： conda create -n py27 python=2.7 #创建一个名字为py27，Python版本为2.7的新环境。Anaconda会自动下载安装相关的软件和包。 激活、退出和删除环境： activate py27 #激活环境 deactivate #退出环境 conda remove --name py27 --all #删除环境 conda env list #列出所有的环境。 1.3 包的管理 Anaconda中包的管理主要通过conda进行，以下命令均在Anaconda Prompt中执行。参阅官方文档。 1.3.1 搜索包 conda search scipy conda search --override-channels --channel defaults scipy #在Anaconda.org搜索 1.3.2 安装包 conda install -n myenv mypackage #在指定环境中安装包 conda install mypackage #在当前环境中安装包 conda install scipy=0.15.0 #安装指定版本的scipy包 conda install scipy curl #同时安装多个包 conda list #列出已安装的包 当然也可以在 Anaconda Prompt 中安装不在Anaconda上的包，但需要确保已在Anaconda中安装了pip包。如果没有安装可以通过conda install pip来安装。接着用pip安装需要的包即可： pip install mypackage #用pip安装包 1.3.3 更新包 conda update mypackage #更新包 conda update python #更新python conda update conda #更新conda conda update anaconda #Update Anaconda metapackage(所有的包) 1.3.4 卸载包 conda remove mypackage #卸载包 1.4 Jupyter Notebook Jupyter Notebook是基于网页的用于交互计算的应用程序。Jupyter Notebook可以在网页中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示。Jupyter可以支持多种语言，它的名字就是三种编程语言的组合：JUlia, PYThon, R。在Jupyter Notebook中使用Python时，其实使用的是IPython内核，所以很多IPython的功能都能在里面使用。 使用Jupyter Notebook之前，建议先更改Jupyter Notebook 打开的目录。右键点击Jupyter Notebook图标选择属性，将目标栏位从...-notebook-script.py %USERPROFILE%修改为...-notebook-script.py D:\\\\MyPython\\\\Dir %USERPROFILE%。其中D:\\\\MyPython\\\\Dir就是你希望打开的目录。 1.4.1 Jupyter Notebook常用技巧 支持同一代码块输出多个语句的执行结果： from IPython.core.interactiveshell import InteractiveShell InteractiveShell.ast_node_interactivity = &quot;all&quot; 使用Matplotlib作图时，需要在代码块第一行加入%matplotlib inline。 Jupyter Notebook中支持执行Shell命令，需要以!开头，比如： !ls *.ipynb !pip install numpy !dir 利用RISE插件可以在Jupyter Notebook中制作幻灯片。 1.5 IPython简介 IPython是一个Python的交互式shell，比原生的python shell好用得多，提供了更为强大的编辑和交互功能，内置了许多很有用的功能和函数。注意：这些命令都只能在IPython交互式命令行工具中使用，不能在Python代码中使用。 1.5.1 帮助 可以搜索官方的最详细的帮助文档，可以点击Spyder工具栏中的HELP查看帮助文档，可以使用help函数查询帮助，比如help(abs) 。 1.5.2 Tab补全 Tab补全功能可以搜索已输入变量（对象、函数等等）的命名空间，可以补全任何对象的方法和属性，可以补全文件路径，可以补全函数的关键词参数（包括等于号=） 。 1.5.3 自省 在变量前后使用问号?，可以显示对象的信息： print? # 或者 ?print def add_numbers(a, b): &quot;&quot;&quot; Add two numbers together Returns ------- the_sum : type of arguments &quot;&quot;&quot; return a + b 使用?符号就可以显示函数的文档字符串： add_numbers? 使用??会显示函数的源码： add_numbers?? 使用?还可以搜索IPython的命名空间。字符与通配符结合可以匹配所有的名字。 import numpy as np np.*load*? 1.5.4 中断运行的代码 代码运行时按Ctrl-C，无论是%run或长时间运行命令，都会导致KeyboardInterrupt。这会导致几乎所有Python程序立即停止。 1.5.5 魔术命令 IPython提供了许多方便易用的魔术命令。魔术命令都带有百分号前缀。详细介绍可参考官方文档。常用的魔术命令有： 魔术命令 说明 %cd Change the current working directory. %dirs Return the current directory stack. %pwd Return the current working directory path. %load Load code into the current frontend. %run Run the named file inside IPython as a program. %conda Run the conda package manager within the current kernel. %time Time execution of a Python statement or expression. %timeit Time execution of a Python statement or expression %who Print all interactive variables, with some minimal formatting. %who_ls Return a sorted list of all interactive variables. %reset Resets the namespace by removing all names defined by the user. 1.6 PyCharm 集成化开发环境（IDE）将代码编辑、调试、运行、发布、环境配置、团队协作等各种功能集成在一个软件中，并且提供多种智能辅助开发手段，可以明显提高开发效率。PyCharm是JetBrains公司专门针对Python语言推出的集成开发环境，分为专业版（Professional）和社区版（Community），后者免费且功能足够一般开发学习使用。 PyCharm以“项目”形式组织Python源代码文件，应当先创建项目、再在其中新建Python文件。关于项目的基本理解要点如下： 开发一个软件往往需要编写大量代码，一般做法是将这些代码分散保存到多个Python程序文件中，再通过相互调用的方式协同运行，以便于代码阅读和修改； 这些属于同一软件的多个程序文件就被视作一个“项目”，一般保存在同一个文件夹中（可以在内部继续创建子文件夹）； 所以在PyCharm中，一个项目对应一个文件夹，里面可以新建多个Python文件。 PyCharm允许为每个项目分别指定不同的Python解释器（以及第三方模块库），具体可以在菜单 File -&gt; Settings -&gt; Project XXX -&gt; Project Interpreter 中添加和选择。事实上PyCharm相当于为每个项目都构建了一个“虚拟运行环境”，里面包含项目需要的所有工具和资源。 可以在PyCharm的菜单 File -&gt; Settings 的 Appearance 和 Editor 中设置界面配色、字体等外观选项。同时在Editor选项的Code Style -&gt; Python 中可以指定TAB缩进行为。建议不勾选 “Tab Character” ，这样每次按下TAB键插入缩进时，Python会自动生成若干空格实现缩进，从而避免使用 “TAB” 字符、防止不同系统下对Python解读混乱。 在PyCharm最左边找到“Structure”选项卡，点击后可以在小窗内显示Python程序的所有变量、函数等名称，便于快速定位。需要了解函数、变量等名称的详细含义时，可以按住CTRL键并将鼠标移动到该名称上。在PyCharm最下方可以找到Python交互式运行窗口和操作系统命令符窗口，以及运行和调试程序时的显示窗口等。调试程序时可以单击代码左侧灰色区域设置断点、使用F8（Step Over）和F7（Step Into）单步调试，同时在屏幕下方看到变量监视窗口。 可以在Code、Edit等菜单中找到 Indent/Unindent（增加/减少缩进）、Comment（添加/删除注释符号）、Surround（用if等结构包含代码）等快速编辑选项。 1.7 语法基础 1.7.1 print 在 Python 中 print 默认是换行的: for i in range(0,3): print (i) ## 0 ## 1 ## 2 要想不换行你应该写成 print(i, end = ’’ ) for i in range(0,3): print (i, end = &#39; &#39;) ## 0 1 2 1.7.2 注释 Python中的注释有单行注释和多行注释：单行注释用 # 开头，多行注释使用三个单引号(’’’)或三个双引号(“““)。注释是代码的重要组成部分，合理使用注释可以增强程序的可读性和可维护性。 1.7.3 变量 变量名只能是数字、字母、下划线组成，但不能以数字开头，不能使用python的关键字。 Python中的变量是没有类型的，我们可以把变量看做是C类语言中(*void)类型的指针。变量是可以指向任何对象的，而对象才是有类型的。 python是弱类型的语言，创建或者修改变量直接赋值即可，不需要声明类型。变量的值可以随意修改，没有类型限制。 变量的赋值过程，例如：a=1，在内存中大致分为两个步骤： 内存中开辟一段空间用于存放值 1 内存中创建一个变量abc，并指向值 1 赋值完成后，若修改 a 的值，python解释器并不是修改变量a指向的内存空间中存放的值，而是重新开辟一段内存空间，将新的值存放进去，变量a重新指向这段新开辟的内存空间。 1.7.4 运行Python程序 在交互式环境中输入代码按下回车就可以执行，或者将python代码保存在.py文件中，在IPython中执行%run命令，或者在IDE中编写代码后点击RUN按钮。 &quot;&quot;&quot; 第一个Python程序 Version: 0.1 Author: XJ &quot;&quot;&quot; ## &#39;\\n第一个Python程序\\n\\nVersion: 0.1\\nAuthor: XJ\\n&#39; str = &quot;Hello, world!&quot; print(str) ## Hello, world! "],["control-flow.html", "Chapter 2 程序控制流程 2.1 if语句 2.2 while循环 2.3 for循环 2.4 continue 2.5 pass 2.6 三元表达式", " Chapter 2 程序控制流程 2.1 if语句 Python中if语句的一般形式如下所示： if condition_1: statement_block_1 elif condition_2: statement_block_2 else: statement_block_3 注意： 每个条件后面要使用冒号 :，表示接下来是满足条件后要执行的语句块。 使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块(block)。Python语言依靠冒号与缩进来表示“从属关系”。 在Python中没有switch – case语句。 2.2 while循环 从 while 后面的冒号开始，下面相对while存在缩进的连续代码均属于“循环体”，将会被重复执行。而从第一个不相对while缩进的语句开始，后面的代码都不再属于这个while的循环体；对于这些语句，只有当while循环彻底结束后才会被执行到。 while 循环在每执行一次循环体后，都会重新检查循环条件。如果循环条件仍然成立则再次执行循环体，否则结束循环。因此假如循环体中的代码不可能改变循环条件的判断结果，那么该循环将永远执行下去，成为“死循环”。构造死循环正规的方式是 while True 。 x = 256; total = 0 while x &gt; 0: if total &gt; 500: break total += x x = x//2 total ## 504 break语句可以跳出当前循环。在多重循环中，一个break语句只能跳出它所在的那一层循环，并不会一次跳出所有循环。continue语句则是直接进入下一次循环、跳过循环体后面的剩余代码。 2.3 for循环 for循环是在一个集合（列表或元组）中进行迭代。循环语句可能带有一个 else 子句；它会在循环遍历完列表 (使用 for) 或是在条件变为假 (使用 while) 的时候被执行，但是不会在循环被 break 语句终止时被执行。 for n in range(4, 6): for w in range(2, n): if n % w == 0: print(n, &#39;=&#39;, w, &#39;*&#39;, n // w) break else: # loop fell through without finding a factor print(n, &#39;is a prime number&#39;) ## 4 = 2 * 2 ## 5 is a prime number 其中，range函数返回一个迭代器，它产生一个均匀分布的整数序列，使用方法为range(start, stop[, step])。比如： # 产生0到4的整数 for i in range(5): print(i) # 产生0到6的整偶数 ## 0 ## 1 ## 2 ## 3 ## 4 for i in range(0, 6, 2): print(i) ## 0 ## 2 ## 4 注意：如果在循环内需要修改序列中的值（比如重复某些选中的元素），推荐你先拷贝一份副本，切片操作使这件事非常简单： words = [&quot;Hello&quot;, &quot;my&quot;, &quot;darling&quot;] for w in words[:]: # Loop over a slice copy of the entire list. if len(w) &gt; 6: words.insert(0, w) 如果写成 for w in words:，这个示例就会创建无限长的列表。 2.4 continue continue 在语法上只会出现于for或 while 循环所嵌套的代码，它会继续执行最近的外层循环的下一个轮次。 for n in range(3, 6): if n % 2 == 0: print(&#39;Find a even number: &#39;, n) continue print(&#39;Find a odd number: &#39;, n) ## Find a odd number: 3 ## Find a even number: 4 ## Find a odd number: 5 2.5 pass pass是空语句，是为了保持程序结构的完整性，它不做任何事情，一般用做占位语句。 if x &lt; 0: print(&#39;negative!&#39;) elif x == 0: pass else: print(&#39;positive!&#39;) 2.6 三元表达式 Python中的三元表达式可以将if-else语句放到一行里。语法为： value = true-expr if condition else false-expr 举例： cond = True x = 100 if cond else 0 x ## 100 "],["built-in-type.html", "Chapter 3 内置数据类型（一） 3.1 None 3.2 字符串 3.3 数字 3.4 布尔值 3.5 Python运算符", " Chapter 3 内置数据类型（一） Python的内置数据类型包括： 数据类型 Python内置数据类型 文本类型 str 数值类型 int, float, complex 序列类型 list, tuple, range 映射类型 dict 集合类型 set, frozenset 布尔类型 bool 二进制类型 bytes, bytearray, memoryview 参考官方文档：https://docs.python.org/3/library/stdtypes.html 本章节主要学习标量类型： 类型 说明 None Python的空值（只存在一个None对象的实例） str 字符串类型，存有Unicode（UTF-8编码）字符串 int 任意精度整数 float 双精度（64位）浮点数（注意没有double类型） bool True或False值 bytes 原生ASCII字节（或Unicode编码为字节） 3.1 None None是Python的空值类型。如果一个函数没有明确的返回值，就会默认返回None。None也常常作为函数的默认参数。None不仅是一个保留字，还是唯一的NoneType的实例： type(None) ## &lt;class &#39;NoneType&#39;&gt; 3.2 字符串 你可以用单引号或双引号来表示字符串。反斜杠 \\可以用来转义，被用来表示特殊字符 。 print(&#39;&quot;Yes,&quot; they said.&#39;) ## &quot;Yes,&quot; they said. print(&quot;\\&quot;Yes,\\&quot; they said.&quot;) ## &quot;Yes,&quot; they said. print(&#39;&quot;Isn\\&#39;t,&quot; they said.&#39;) ## &quot;Isn&#39;t,&quot; they said. 如果字符串中包含许多反斜杠，但没有特殊字符，这样做就很麻烦。幸好，可以在字符串前面加一个r，表明\\字符就是它自身，r的含义是原始字符串raw： s = r&#39;this\\has\\no\\special\\characters&#39; print(s) ## this\\has\\no\\special\\characters 字符串字面值可以跨行连续输入。一种方式是用三重引号：\"\"\"...\"\"\" 或 '''...'''。字符串行尾会自动加上回车换行，如果不需要回车换行，在行尾添加一个 \\ 即可。如下例： print(&quot;&quot;&quot;Line 1 Line 2 Line 3 &quot;&quot;&quot;) ## Line 1 ## Line 2 ## Line 3 字符串可以用 + 进行连接（粘到一起），也可以用 * 进行重复： 3 * &#39;un&#39; + &#39;ium&#39; ## &#39;unununium&#39; 相邻的两个或多个字符串字面值（引号引起来的字符）将会自动连接到一起。只能对两个字面值这样操作，变量或表达式不行。如果你想连接变量，或者连接变量和字面值，可以用 + 号。 &#39;Py&#39; &#39;thon&#39; ## &#39;Python&#39; pre = &#39;py&#39; pre + &#39;thon&#39; ## &#39;python&#39; 拆分长字符串时，这个功能特别实用： text = (&#39;Put several strings within parentheses &#39; &#39;to have them joined together.&#39;) text ## &#39;Put several strings within parentheses to have them joined together.&#39; 字符串是可以被索引（下标访问）的，第一个字符索引是0。单个字符并没有特殊的类型，只是一个长度为一的字符串： word = &#39;Python&#39; word[0] #&#39;P&#39; ## &#39;P&#39; word[-1] #&#39;n&#39; ## &#39;n&#39; 除了索引，字符串还支持切片。索引可以得到单个字符，而 切片可以获取子字符串。注意切片的开始总是被包括在结果中，而结束不被包括。这 使得 s[:i] + s[i:] 总是等于 s。 word[:2] #&#39;Py&#39; ## &#39;Py&#39; Python中的字符串不能被修改，它们是不可变类型（immutable ）。因此，向字符串的某个索引位置赋值会产生错误。 在Python 3中推荐使用f-Strings 进行字符串格式化。f-strings是指以 f 或 F 开头的字符串，其中以 {} 包含的表达式会进行值替换。 name = &#39;hoxis&#39; age = 18 f&quot;hi, {name}, are you {age}&quot; ## &#39;hi, hoxis, are you 18&#39; 因为f-strings是在运行时计算的，那么这就意味着你可以在其中放置任意合法的Python表达式，比如： f&quot;{ 2 * 3 + 1}&quot; ## &#39;7&#39; import math print(f&#39;The value of pi is approximately {math.pi:.3f}.&#39;) ## The value of pi is approximately 3.142. name = &quot;Fred&quot; f&quot;He said his name is {name!r}.&quot; ## &quot;He said his name is &#39;Fred&#39;.&quot; width = 10 precision = 4 value = 12.34567 f&quot;result: {value:{width}.{precision}}&quot; ## &#39;result: 12.35&#39; 3.2.1 字符串格式化语法 格式字符串包含有以花括号 {} 括起来的“替换字段”。不在花括号之内的内容会被视为字面文本直接输出。替换字段的语法如下： replacement_field ::= &quot;{&quot; [field_name] [&quot;!&quot; conversion] [&quot;:&quot; format_spec] &quot;}&quot; field_name ::= arg_name (&quot;.&quot; attribute_name | &quot;[&quot; element_index &quot;]&quot;)* arg_name ::= [identifier | digit+] attribute_name ::= identifier element_index ::= digit+ | index_string index_string ::= &lt;any source character except &quot;]&quot;&gt; + conversion ::= &quot;r&quot; | &quot;s&quot; | &quot;a&quot; format_spec ::= &lt;described in the next section&gt; field_name 本身以一个数字或关键字 arg_name 打头。如果为数字，则它指向一个位置参数，而如果为关键字，则它指向一个命名关键字参数。 如果格式字符串中的数字 arg_names 为 0, 1, 2, … 的序列，它们可以全部省略（而非部分省略），数字 0, 1, 2, … 将会按顺序自动插入。由于 arg_name 不使用引号分隔，因此无法在格式字符串中指定任意的字典键 (例如字符串 ‘10’ 或 ‘:-]’)。arg_name 之后可以带上任意数量的索引或属性表达式。‘.name’ 形式的表达式会使用 getattr() 选择命名属性，而 ‘[index]’ 形式的表达式会使用 __getitem__() 执行索引查找。 一些简单的格式字符串示例： &quot;First, thou shalt count to {0}&quot; # References first positional argument &quot;Bring me a {}&quot; # Implicitly references the first positional argument &quot;From {} to {}&quot; # Same as &quot;From {0} to {1}&quot; &quot;My quest is {name}&quot; # References keyword argument &#39;name&#39; &quot;Weight in tons {0.weight}&quot; # &#39;weight&#39; attribute of first positional arg &quot;Units destroyed: {players[0]}&quot; # First element of keyword argument &#39;players&#39;. 一般约定空的格式描述将产生与在值上调用 str() 相同的结果。非空格式描述通常会修改此结果。标准格式说明符(format_spec)的一般形式如下： format_spec ::= [[fill]align][sign][#][0][width][grouping_option][.precision][type] fill ::= &lt;any character&gt; align ::= &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;=&quot; | &quot;^&quot; sign ::= &quot;+&quot; | &quot;-&quot; | &quot; &quot; width ::= digit+ grouping_option ::= &quot;_&quot; | &quot;,&quot; precision ::= digit+ type ::= &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot; &#39;{}, {}, {}&#39;.format(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) ## &#39;a, b, c&#39; &#39;{2}, {1}, {0}&#39;.format(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) ## &#39;c, b, a&#39; &#39;{:&gt;30}&#39;.format(&#39;right aligned&#39;) ## &#39; right aligned&#39; &#39;{:*^30}&#39;.format(&#39;centered&#39;) # use &#39;*&#39; as a fill char ## &#39;***********centered***********&#39; import datetime d = datetime.datetime(2010, 7, 4, 12, 15, 58) &#39;{:%Y-%m-%d %H:%M:%S}&#39;.format(d) ## &#39;2010-07-04 12:15:58&#39; print(&#39;name rate&#39;.center(30,&#39;-&#39;)) ## ----------name rate---------- 3.3 数字 Python的主要数值类型是int和float。 3**3 ## 27 (30 - 2 * 3) / 5 ## 4.8 在交互模式下，上一次打印出来的表达式被赋值给变量 _： 2 + _ #6.8 3.3.1 浮点数 因为浮点数在转换为二进制表示之后变成了无限长度小数，计算机不得不对它进行截断，从而导致计算误差。可以使用内置函数round(原始数值, 保留小数位数) 实现四舍五入。Python3 中使用“银行家舍入法”，当一个值刚好在两个边界的中间的时候，round 函数返回离它最近的偶数。也就是说，对 1.5 或者 2.5 的舍入运算都会得到 2。传给 round() 函数的 ndigits 参数可以是负数，这种情况下，舍入运算会作用在十位、百位、千位等上面。 round(1.345, 2) ## 1.34 round(123456, ndigits = -2) ## 123500 在真实世界中很少会要求精确到普通浮点数能提供的 17 位精度，而且原生的浮点数计算要快得多。因此，大多数情况下计算过程中的微小误差是被允许的。 如果不能允许这样的小误差(比如涉及到金融领域)，那么就得考虑使用 decimal 模块了。Decimal 对象可以根据给定的参数（字符串形式）创建十进制数字对象，并完全基于十进制规则计算，从而避免二进制舍入误差。但是如果使用数字作为 Decimal 的参数，它就会先被 python 转换为二进制数字再交给Decimal，仍然可能引入精度误差。Decimal 类型的数字不能与普通小数直接运算；含有 Decimal 型数字的计算式，计算结果也是 Decimal 类型，可以使用 float() 等转换为普通数字。 from decimal import Decimal Decimal(0.1)+Decimal(0.2) ## Decimal(&#39;0.3000000000000000166533453694&#39;) Decimal(&#39;0.1&#39;)+Decimal(&#39;0.2&#39;) ## Decimal(&#39;0.3&#39;) from decimal import getcontext getcontext().prec= 6 Decimal(2).sqrt() ## Decimal(&#39;1.41421&#39;) Decimal(2) ** Decimal(&#39;0.5&#39;) ## Decimal(&#39;1.41421&#39;) 还有一个办法就是可以将小数转换为整数进行加、减、乘等运算，以利用Python长整型无溢出的特点，快速得到精确结果。但是如果需要在结果中添加小数点，建议先将其转换为字符串再使用切片操作，而不是直接除以 \\(10^n\\) ，因为整数除法还是会产生浮点数，导致截断误差。 #示例代码： def getDecLen(s): loc = s.find(&#39;.&#39;) if loc == -1: result = 0 else: result = len(s)-loc-1 return result # 下面是主程序，接受用户输入并计算结果 def precise_mult(x=1.23, y=3.21): # 根据getDecLoc函数得到x和y的小数位数并相加，将小数总位数计入变量 decLen x = str(x) y = str(y) decLen = getDecLen(x) + getDecLen(y) # 删除两个乘数x和y中的小数点，转换为整数计算， # 再把计算结果转换为字符串 z = int(x.replace(&#39;.&#39;, &#39;&#39;)) * int(y.replace(&#39;.&#39;, &#39;&#39;)) z = str(z) # 如果乘数都是整数，即乘积中没有小数（小数总位数decLen为0）则不添加小数点 # 否则先判断乘积 z 的长度，如果小于应有的小数位数，就在左边先补零 # 这是为了防止下面情况的出现：0.2*0.3 结果应有两位小数，但 2*3 的结果6只有一位数字 # 所以需要在前面补充2个0，即006，然后才能插入小数点为 0.06 。 if decLen &gt; 0: if len(z) &lt; decLen: z = &#39;0&#39;*(decLen-len(z)+1) + z # 完成必要的补零后，即可用负数切片操作，在小数前面插入小数点。 z = z[:-decLen] + &#39;.&#39; + z[-decLen:] print(f&#39;{x}×{y}={z}&#39;) 0.1*0.2 ## 0.020000000000000004 precise_mult(0.1, 0.2) ## 0.1×0.2=0.02 3.3.2 无穷大与NaN Python 并没有特殊的语法来表示这些特殊的浮点值，但是可以使用 float() 来创建它们。比如： a = float(&#39;inf&#39;) b = float(&#39;-inf&#39;) c = float(&#39;nan&#39;) a ## inf math.isinf(a) ## True math.isnan(c) ## True 无穷大数在执行数学计算的时候会传播，NaN值会在所有操作中传播，而不会产生异常。NaN 值的一个特别的地方是它们之间的比较操作总是返回 False。由于这个原因，测试一个 NaN 值得唯一安全的方法就是使用math.isnan()。 a*10 ## inf c/a ## nan c == c ## False 3.3.3 分数 fractions 模块可以被用来执行包含分数的数学运算。 from fractions import Fraction a = Fraction(5, 4) b = Fraction(7, 16) print(a + b) ## 27/16 print(a * b) ## 35/64 a.numerator; a.denominator ## 5 ## 4 # Converting a float to a fraction x = 3.75 Fraction(*x.as_integer_ratio()) ## Fraction(15, 4) 3.3.4 随机数 random 模块有大量的函数用来产生随机数和随机选择元素。比如： import random # 从一个序列中随机的抽取一个元素 values = [1, 2, 3, 4, 5, 6] random.choice(values) ## 5 # 提取出 N 个不同元素的样本： random.sample(values, 3) ## [4, 1, 2] # 打乱序列中元素的顺序 random.shuffle(values) values ## [4, 5, 1, 2, 3, 6] # 生成随机整数 random.randint(0,20) # 生成 0 到 1 范围内均匀分布的浮点数 ## 3 random.random() ## 0.15146045159358423 可以通过 random.seed() 函数修改初始化种子： random.seed(123) random.random() ## 0.052363598850944326 3.4 布尔值 Python中的布尔值有两个，True和False。布尔类型（逻辑类型）其实是整数类型（int）的子类，True和False在算术式中会被自动视作1和0 。 一个对象在默认情况下均被视为 True ，除非当该对象被调用时其所属类定义了__bool__() 方法且返回 False 或是定义了__len__() 方法且返回0。 下面基本完整地列出了会被视为 False 的内置对象: 被定义为假值的常量: None 和 False。 任何数值类型的零: 0, 0.0, 0j, Decimal(0), Fraction(0, 1) 空的序列和多项集: ’’, (), [], {}, set(), range(0) 产生布尔值结果的运算和内置函数总是返回 0 或 False 作为假值，1 或 True 作为真值，除非另行说明。内置函数 bool() 可以根据前述规则得到某个数据的对应逻辑值。需要注意的是：根据前述规则，bool(“False”) 的结果是True而非False。 bool(&quot;False&quot;) ## True 3.5 Python运算符 3.5.1 算术运算符 参考官方文档：https://docs.python.org/zh-cn/3/library/stdtypes.html#numeric-types-int-float-complex 运算 说明 a+b a加b a-b a减b a*b a乘以b a/b a除以b a%b 取模 - 返回除法的余数 a//b 取整除 - 返回商的整数部分（向下取整） a**b a的b次幂 3.5.2 比较运算符 运算符 说明 a&amp;b a或b都为True，则为True；对于整数，取逐位AND a|b a或b有一个为True，则为True；对于整数，取逐位OR a^b 对于布尔，a或b有一个为True，则为True，二者都为True，为False；对于整数，取逐位EXCLUSIVE-OR a==b a等于b，则为True a!=b a不等于b，则为True a&lt;b，a&lt;=b a小于（或小于等于）b，则为True a&gt;b，a&gt;=b a大于（或大于等于）b，则为True 可以把比较运算符串在一起: a&gt;b&gt;c&gt;d： 5&gt;2&gt;3&gt;1 ## False 3.5.3 逻辑运算符 逻辑运算符包括 and 、or 和 not。一个判断子句中可以使用多个关系表达式表达复杂条件，只要使用逻辑运算符 and、or、not 等将其组合在一起即可。优先级排序：not &gt; and &gt; or。可以使用圆括号修改优先级。 运算符 描述 and 两端的逻辑值全部为 True， 则计算结果为 True；任何一端为False，则计算结果为 False or 两端的逻辑值只要有一个为 True，计算结果就是 True；如果两端都为 False，则结果为 False not 结果为右侧逻辑值的取反值 all(iterable) 如果 iterable 的所有元素均为真值（或可迭代对象为空）则返回 True any(iterable) 如果 iterable 的任一元素为真值则返回 True。 如果可迭代对象为空，返回 False。 a = 5; b = 10 (a&gt;b) and (b&lt;12) or (a&gt;1) and not a ## False # 注意： all([]); any([]) ## True ## False 3.5.4 成员运算符 运算符 描述 in 如果在指定的序列中找到值返回 True，否则返回 False。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 3.5.5 身份运算符 运算符 描述 实列 is 判断两个标识符是不是引用自一个对象 x is y, 等同于 id(x) == id(y) is not 判断两个标识符是不是引用自不同对象 x is not y, 等同于 id(x) != id(y) is 与 == 区别：is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， == 用于判断引用变量的值是否相等。对于 a 和 b 两个变量，如果 a is b 为 True，则 a==b 一定为 True；反之如果 a==b 为True，a is b 有可能是 False。 程序运行时，Python会在内存中维护一个“变量表”。里面每条记录都保存了一个变量的信息，其中关键两个信息是该变量的名字、该变量所指向的内存地址号码。当 Python 需要读取数据时，首先根据变量名得到这个地址，然后再根据该地址，找到真实数据。 使用内置函数 id() 可以获取对象内存地址。修改一个变量的取值时，Python 只是修改了这个变量所存储的地址号码，从而让它指向新数值的所在位置，并不会修改原来那个位置的原数值。原数值将一直保留在其内存单元中，直到Python将其收回。 为提高程序效率，Python会预先创建好 -5 至 256 范围内的常用小整数，保存在内存中固定位置。当程序用到这些整数时，不必再次重复创建，因而执行 a=3 和 b=1+2 后，a 与 b 指向同一内存地址，即 a is b 返回 True。 a = 1; b = 1 print(f&quot;a的内存地址是{id(a)}，b的内存地址是{id(b)}&quot;) ## a的内存地址是140711062939424，b的内存地址是140711062939424 a is b ## True a=5555; b=5555 a is b ## True 从 python 3.8 开始，使用 is 和 is not 运算符时，会抛出 SyntaxWarning 语句警告信息，建议分别使用 == 和 != 代替。 "],["built-in-type2.html", "Chapter 4 内置数据类型（二） 4.1 列表list 4.2 元组tuple 4.3 字典dict 4.4 集合set 4.5 数据类型判断", " Chapter 4 内置数据类型（二） 4.1 列表list list是Python内置的一种数据类型，list是一个可变的有序表，可以随时添加和删除其中的元素。比如，列出班里所有同学的名字，就可以用一个list表示： x = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;] list里面的元素的数据类型可以不同， l = [&#39;Apple&#39;, 123, True] # list的元素也可以是另一个list s = [&#39;python&#39;, &#39;java&#39;, [&#39;asp&#39;, &#39;php&#39;], &#39;scheme&#39;] 4.1.1 索引和切片 用len()函数可以计算list中元素的个数。用索引可以访问list中每一个位置的元素，索引是从0开始的，最后一个元素的索引是len(x) - 1 。可以用-1做索引直接获取最后一个元素，用-2做索引可以直接获取倒数第二个元素。 len(x) ## 3 x[-2];x[1] ## &#39;Bob&#39; ## &#39;Bob&#39; #切片 s = [1,2,3,4,5,6] s[1:3]; s[-2:] ## [2, 3] ## [5, 6] 4.1.2 列表修改 list是可变对象，可以使用下列函数对列表中的元素进行修改。 x.append(&#39;Adam&#39;) # 可以往list中追加元素到末尾 # 也可以把元素插入到指定的位置 x.insert(1, &#39;Jack&#39;) # 可以用pop()方法删除list中的元素 x.pop(2) ## &#39;Bob&#39; # 可以直接赋值给对应的索引位置 x[1] = &#39;Sarah&#39; # 用in可以检查列表是否包含某个值 &#39;Sarah&#39; in x ## True 4.1.3 列表排序 List的sort()方法可以对原列表进行排序，如果列表中的数据类型不同则会报错。 x.sort() x.reverse() # 反转列表中元素 print(x) ## [&#39;Tracy&#39;, &#39;Sarah&#39;, &#39;Michael&#39;, &#39;Adam&#39;] x = [&#39;a&#39;,1,&#39;b&#39;,2,] x.sort() # list 和 str 不能相互比较 4.1.4 列表复制 copy() 函数用于复制列表，等同于 a[:]。 y = x.copy() arr = [{&#39;name&#39;: &#39;wcl&#39;, &#39;age&#39;: 23}, {&#39;name&#39;: &#39;wjy&#39;, &#39;age&#39;: 14}] arr2 = arr.copy() del arr[1] arr[0][&#39;age&#39;] = 18 print(&#39;arr：&#39;, arr) ## arr： [{&#39;name&#39;: &#39;wcl&#39;, &#39;age&#39;: 18}] print(&#39;arr2：&#39;, arr2) ## arr2： [{&#39;name&#39;: &#39;wcl&#39;, &#39;age&#39;: 18}, {&#39;name&#39;: &#39;wjy&#39;, &#39;age&#39;: 14}] 可以看出，copy() 只是是浅度复制，修改列表不会互相影响，但是修改列表里面的对象会影响到对方列表里面对象。 4.2 元组tuple 另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改。元组使用小括号()，列表使用方括号[]。 names = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;) tup = &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot; # 不用括号也可以 元组对象的“不可变性”，是指元组内部保存的各个地址号码不允许修改；但是这些号码所指向的内存单元中如果是可变对象（比如列表），那么这些可变对象仍可随意修改，与元组无关。 x = [1,2,3] tup = (&quot;abc&quot;, x) print(tup) ## (&#39;abc&#39;, [1, 2, 3]) x[0] = 100 print(tup) ## (&#39;abc&#39;, [100, 2, 3]) tuple没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用names[0]，names[-1]，但不能赋值成另外的元素。不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 只有1个元素的tuple定义时必须加一个逗号,，来消除歧义 t = (1,); t ## (1,) 4.2.1 元组运算符 与字符串一样，元组之间可以使用 + 号和 * 号进行运算。这意味着元组可以组合和复制，运算后会生成一个新的元组。可以用加号运算符将元组串联起来： (4, None, &#39;foo&#39;) + (6, 0) + (&#39;bar&#39;,) ## (4, None, &#39;foo&#39;, 6, 0, &#39;bar&#39;) 可以用切片的方式更新元组： T = (&#39;aa&#39;,&#39;bb&#39;,&#39;cc&#39;,&#39;dd&#39;,&#39;ee&#39;) T = T[0:3]+T[4:] # T = T[0:3]+T[4] 会报错 print(T) ## (&#39;aa&#39;, &#39;bb&#39;, &#39;cc&#39;, &#39;ee&#39;) 复制元组： (&quot;abc&quot;,)*3 ## (&#39;abc&#39;, &#39;abc&#39;, &#39;abc&#39;) 判断元素: &#39;aa&#39; in T ## True 4.3 字典dict Python内置了字典（dict），dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。 d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85} d[&#39;Michael&#39;] ## 95 给定一个名字，比如'Michael'，dict在内部就可以直接计算出Michael对应的存放成绩的”页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。 # 把数据放入dict，除了初始化时指定外，还可以通过key放入 d[&#39;Adam&#39;] = 67 # dict可以接受2元元组的列表 mapdict = dict(zip(range(5), reversed(range(5)))) del mapdict[0] # 等同于 mapdict.pop(0) print(mapdict) ## {1: 3, 2: 2, 3: 1, 4: 0} 字典值可以是任何的 python 对象，既可以是标准的对象，也可以是用户定义的。但是键（key)则有明确的限制：首先是不重复，创建时如果同一个键被赋值两次，只有后一个值会被记住；其次是不可变，dict的key必须是不可变对象，只能用用数字，字符串或元组充当。 dict内部存放的顺序和key放入的顺序是没有关系的。和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict是“以空间换时间”的数据结构，即在内存中事先存储好所有键值对，从而在查询时可以直接依据键找到值、节省检索时间。dict可以用在需要高速查找的地方。 4.3.1 字典操作 dict.keys(), dict.values() 和 dict.items() 返回的对象是视图对象。它们提供了字典条目的动态视图，这意味着当字典发生变化时，视图会反映这些变化。他们返回的都是可迭代对象。dict.keys()返回字典所有的键；dict.values()返回该字典所有的值； dict.items() 返回字典所有的键值对(key, value)。使用 for k in dict循环遍历字典元素时，每次循环的变量 k 都是字典中的键。键视图类似集合，因为key是唯一且可散列的（hashable）。 dic = {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3,} for i in dic: print(i) ## a ## b ## c for i in dic.values(): print(i) ## 1 ## 2 ## 3 字典可以通过以下方法调换 key和 value，当然要注意原始 value 的类型,必须是不可变类型： reverse = {v: k for k, v in dic.items()} print(reverse) ## {1: &#39;a&#39;, 2: &#39;b&#39;, 3: &#39;c&#39;} 通过 values 取到 key 的方法： dic={&quot;a&quot;:5,&quot;b&quot;:3,&quot;c&quot;:1} list(dic.keys())[list(dic.values()).index(3)] ## &#39;b&#39; 4.3.2 字典合并 可以将两个字典合并，遇到相同的键则用字典Y去更新字典X的值。字典的update方法只会修改原字典，不会创造一个新的字典。 x = {&#39;a&#39;: 1, &#39;b&#39;: 2} y = {&#39;b&#39;: 10, &#39;c&#39;: 11} x.update(y) print(x) ## {&#39;a&#39;: 1, &#39;b&#39;: 10, &#39;c&#39;: 11} 如果想不修改原字典，而是得到一个新字典，可以使用下面的方法。 # Python 3.5+ z = {**x, **y} print(z) ## {&#39;a&#39;: 1, &#39;b&#39;: 10, &#39;c&#39;: 11} 如果是 Python 3.9+ 还能使用z = x | y实现这个目的。 4.3.3 fromkeys() fromkeys()是字典类型的方法，所以必须先有一个字典对象，再调用该对象的fromkeys方法。常用写法为 d={}.fromkeys(a, x) （或者d=dict.fromkeys(a, x)），即将 a 中每一个元素都作为键，对应的值统一为x，从而构建一个新字典，并将该字典返回给变量 d 。 使用 fromkeys() 时必须注意以下常见问题： - d.fromkeys(a) 并不会修改 d ，而是建立一个新字典，而且新字典中的内容也完全不受 d 中已有元素的影响； - 假如 a 中某个元素也是一个容器，那么该容器整体被作为一个键，而不是拆分成键值对； - 通过 d = {}.fromkeys(a,x) 创建的新字典 d ，其中所有元素的值都指向同一个内存地址即 x ，因此“一改全改”。 - d = {}.fromkeys(a, b) 中，即使 a 和 b 都是列表，也不会将这两个列表合并为一个字典，而是会让新字典 d 中所有键都指向同一个列表 b 。 {}.fromkeys([1,2,3], [2,3,4]) # 等价于dict.fromkeys([1,2,3], [2,3,4]) ## {1: [2, 3, 4], 2: [2, 3, 4], 3: [2, 3, 4]} 4.4 集合set set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以在set中没有重复的key。集合类型有以下特点和要求： 禁止出现重复元素； 不能指定元素的顺序，不像列表那样按照添加的先后顺序排列； 只能使用不可变对象（数字、逻辑值、元组、字符串等）作为元素。 创建集合时必须传入可迭代对象。可以使用 set() 将列表、元组、字典，以及 range、zip 等可迭代对象转换为集合。转换过程中，原列表等容器里的重复元素会被自动删除。如果将字典转换为集合，得到的集合是由字典中所有元素的键构成、不包含值。空集合的表示方法为 set() ，而不是{} 。后者代表空的字典对象。 set([1, 2, 3]) ## {1, 2, 3} 注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这三个元素，显示的顺序也不表示set是有序的。重复元素在set中自动被过滤： s = set([1, 1, 2, 2, 3, 3]) set(123) # TypeError: &#39;int&#39; object is not iterable s.add(4)可以添加元素到set中；s.update(x)也可以添加元素，且参数可以是列表，元组，字典等。 s.update({5,3}) print(s) ## {1, 2, 3, 5} s.remove(4)可以删除元素，s.discard(x)也是移除集合中的元素，且如果元素不存在，不会发生错误。 注意当集合只有一个元素时的创建方法： set(&quot;Hello&quot;) ## {&#39;H&#39;, &#39;l&#39;, &#39;o&#39;, &#39;e&#39;} set((&quot;Hello&quot;,)) ## {&#39;Hello&#39;} 4.4.1 集合运算 set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作： s1 = set([1, 2, 3]) s2 = set([2, 3, 4]) s1 &amp; s2 # 交 ## {2, 3} s1 | s2 # 并 ## {1, 2, 3, 4} s1 - s2 # 差 ## {1} s1 ^ s2 # 两个集合中不重复的元素集合 ## {1, 4} 4.5 数据类型判断 使用 type(x) 可以得到一个type类对象，该对象的属性中保存了名称 x 的数据类型信息。特别是该对象的 __name__ 属性，就是变量 x 的类型名称。比如 type(3.14).__name__ 得到的就是字符串 ‘float’ 。由于 type 函数将类型名称作为字符串返回，所以实际编程时容易因为字符串笔误等原因造成隐患；同时该函数无法用于分辨一个类型是否属于其父类（比如bool类型数据True是否也是一个int类型的数据），因此一般更推荐使用 isinstance 函数。 isinstance(x, 类型名) 可以返回一个逻辑值True或False，代表x是否属于指定类型。其中类型名不是字符串形式，而是直接书写，比如 isinstance(x, int) 。 x = 1 isinstance(x, int) ## True 4.5.1 可变与不可变 Python中的大多数对象，比如列表、字典、集合、NumPy数组、用户定义的类，都是可变的。这意味着这些对象或包含的值可以被修改。其它的，比如数字、字符串和元组，是不可变的： a_tuple = (3, 5, (4, 5)) a_tuple[1] = &#39;four&#39; #TypeError 4.5.2 hashable 官方文档对hashable的说明： 一个对象的哈希值如果在其生命周期内绝不改变，就被称为 可哈希（它需要具有 __hash__() 方法），并可以同其他对象进行比较（它需要具有 __eq__() 方法）。可哈希对象必须具有相同的哈希值比较结果才会相同。 可哈希性使得对象能够作为字典键或集合成员使用，因为这些数据结构要在内部使用哈希值。 大多数 Python 中的不可变内置对象都是可哈希的；可变容器（例如列表或字典）都不可哈希；不可变容器（例如元组和 frozenset）仅当它们的元素均为可哈希时才是可哈希的。 用户定义类的实例对象默认是可哈希的。 它们在比较时一定不相同（除非是与自己比较），它们的哈希值的生成是基于它们的 id()。 "],["container.html", "Chapter 5 深入理解各种容器 5.1 序列函数 5.2 列表推导式 5.3 迭代器 5.4 生成器 5.5 解包 5.6 排序 5.7 collections 5.8 拷贝", " Chapter 5 深入理解各种容器 5.1 序列函数 5.1.1 enumerate函数 enumerate函数语法为：enumerate(sequence, [start=0])，返回(i, value)元组序列，start是下标起始位置： seasons = [&#39;Spring&#39;, &#39;Summer&#39;, &#39;Fall&#39;, &#39;Winter&#39;] list(enumerate(seasons)) ## [(0, &#39;Spring&#39;), (1, &#39;Summer&#39;), (2, &#39;Fall&#39;), (3, &#39;Winter&#39;)] list(enumerate(seasons, start = 2)) ## [(2, &#39;Spring&#39;), (3, &#39;Summer&#39;), (4, &#39;Fall&#39;), (5, &#39;Winter&#39;)] 5.1.2 zip函数 zip()函数将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象。在 Python 3 中，为了节省空间，zip()返回的是一个由元组构成的迭代器，用list(zip(a, b))可以强制转换成列表，在这个列表中，每个元素是一个元组；对于第i个元组，它其中的内容是(a[i-1], b[i-1])。 seq1 = [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;] seq2 = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;] zipped = zip(seq1, seq2) list(zipped) ## [(&#39;foo&#39;, &#39;one&#39;), (&#39;bar&#39;, &#39;two&#39;), (&#39;baz&#39;, &#39;three&#39;)] list(zip(&quot;Hello&quot;, &quot;World&quot;)) ## [(&#39;H&#39;, &#39;W&#39;), (&#39;e&#39;, &#39;o&#39;), (&#39;l&#39;, &#39;r&#39;), (&#39;l&#39;, &#39;l&#39;), (&#39;o&#39;, &#39;d&#39;)] zip()可以处理任意多的序列，元素的个数取决于最短的序列。zip的常见用法之一是同时迭代多个序列，可能结合enumerate使用 。加上星号（*）,input1, input2 = zip(*output)能够实现output = zip(input1, input2)的逆向操作。利用这个技巧可以把行的列表转换为列的列表。 x1 = (&#39;Nolan&#39;, &#39;Roger&#39;, &#39;Schilling&#39;) x2 = (&#39;Ryan&#39;, &#39;Clemens&#39;, &#39;Curt&#39;) X = list(zip(x1, x2)) print(X) ## [(&#39;Nolan&#39;, &#39;Ryan&#39;), (&#39;Roger&#39;, &#39;Clemens&#39;), (&#39;Schilling&#39;, &#39;Curt&#39;)] Y = list(zip(*X)) print(Y) ## [(&#39;Nolan&#39;, &#39;Roger&#39;, &#39;Schilling&#39;), (&#39;Ryan&#39;, &#39;Clemens&#39;, &#39;Curt&#39;)] strs = [&quot;flower&quot;, &quot;flow&quot;, &quot;flight&quot;] print(list(zip(*strs))) ## [(&#39;f&#39;, &#39;f&#39;, &#39;f&#39;), (&#39;l&#39;, &#39;l&#39;, &#39;l&#39;), (&#39;o&#39;, &#39;o&#39;, &#39;i&#39;), (&#39;w&#39;, &#39;w&#39;, &#39;g&#39;)] 5.2 列表推导式 列表推导式(list comprehensions)允许用户基于一个已有的列表生成新列表，在生成新列表的过程中还可以变换、过滤元素。语法格式如下： # 列表 [expr for val in iterable if condition] # 字典 dict_comp = {key-expr : value-expr for value in iterable if condition} # 集合 set_comp = {expr for value in iterable if condition} 举例如下： print([i**2 for i in range(20) if i % 3 is 0]) ## [0, 9, 36, 81, 144, 225, 324] print({i: i * i for i in range(10)}) ## {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25, 6: 36, 7: 49, 8: 64, 9: 81} mcase = {&#39;a&#39;: 10, &#39;b&#39;: 34} print({v: k for k, v in mcase.items()}) ## {10: &#39;a&#39;, 34: &#39;b&#39;} print({x**2 for x in [1, 1, 2]}) ## {1, 4} 5.2.1 if-else模式 形式如下：newlist = [expr1 if condition else expr2 for for val in iterable]。此处if…else主要起赋值作用，当iterable中的数据满足if条件时将其做expr1处理，否则按照expr2处理，最后统一生成为一个数据列表。 例子：1-10中，偶数取相反数，其余的数保持不变： [-x if x%2==0 else x for x in range(1,11)] ## [1, -2, 3, -4, 5, -6, 7, -8, 9, -10] 5.2.2 嵌套推导式 嵌套列表推导式可以包含多层for循环，直接看列子： some_tuples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)] flattened = [x for tup in some_tuples for x in tup if x&gt;5] flattened ## [6, 7, 8, 9] [(x,y) for x in [1,2,3] if x!=2 for y in[3,1,4] if x!=y] ## [(1, 3), (1, 4), (3, 1), (3, 4)] 可以使用嵌套列表推导式创建二维列表（矩阵）。 x = [ [0]*8 for _ in range(4) ] x ## [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]] matrix = [[i for i in range(5)] for _ in range(5)] matrix ## [[0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4], [0, 1, 2, 3, 4]] 可以实现矩阵转置： # 3x4的矩阵 matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]] # 用列表推导式交换其行和列 [ [row[i] for row in matrix] for i in range(4) ] ## [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] # 注意区别： [ row[i] for row in matrix for i in range(4) ] ## [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] 可以参考列表推导式使用方法。 5.3 迭代器 你可能注意到大多数容器对象都可以用 for遍历： for element in [1, 2, 3]: print(element) for element in (1, 2, 3): print(element) for key in {&#39;one&#39;:1, &#39;two&#39;:2}: print(key) for char in &quot;123&quot;: print(char) for line in open(&quot;myfile.txt&quot;): print(line, end=&#39;&#39;) 其实背后是迭代器在起作用。迭代器有两个基本的方法：iter() 和 next()。在后台，for语句调用容器对象的__iter__()方法。该函数返回一个定义了__next__()方法的迭代器对象，它一次访问容器中的一个元素。没有后续的元素时，__next__() 会引发StopIteration异常，告诉 for循环停止迭代。有两个内置函数可以应用于迭代器：iter()用于返回一个迭代器; next()返回迭代器的下一个元素，例如： s = &#39;abc&#39; it = iter(s) it ## &lt;str_iterator object at 0x00000000266F8340&gt; next(it), next(it) ## (&#39;a&#39;, &#39;b&#39;) 5.3.1 创建一个迭代器 只要一个对象实现了__iter__()和__next__()方法，那么它就是一个迭代器对象。 class MyNumbers: def __iter__(self): self.a = 1 return self def __next__(self): if self.a &lt;= 20: x = self.a self.a += 1 return x else: raise StopIteration myclass = MyNumbers() myiter = iter(myclass) print(next(myiter)) ## 1 print(next(myiter)) ## 2 5.4 生成器 生成器（generator）是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。生成器仅仅保存了一套生成值的算法 ，并没有让这个算法立即执行，而是什么时候调它，它什么时候开始计算并且返回一个值。生成器对象具有惰性求值的特点，不管用哪种方法访问生成器对象，都无法再次访问已访问过的元素。 5.4.1 生成器推导式 只要把一个列表生成式的[] 改成() ，就得到生成器推导式 # 生成器 generator_ex = ( x*x for x in range(10) ) print(generator_ex) ## &lt;generator object &lt;genexpr&gt; at 0x00000000266A4350&gt; print(next(generator_ex)) # 通过内置函数next( )执行会打印 0 ## 0 5.4.2 yield关键字 要创建一个生成器，只需将函数中的return替换为yeild即可。在调用生成器运行的过程中，每次遇到yield时函数会暂停并保存当前所有的运行信息，返回yield后面的值, 并在下一次执行内置函数next()时从当前位置继续运行，从而节省内存。 def fibonacci(n): # 生成器函数 - 斐波那契 a, b, counter = 0, 1, 0 while True: if (counter &gt; n): return yield a a, b = b, a + b counter += 1 f = fibonacci(10) # f 是一个迭代器，由生成器返回生成 while True: try: print(next(f), end=&quot; &quot;) except StopIteration: break ## 0 1 1 2 3 5 8 13 21 34 55 5.5 解包 任何的序列（或者是可迭代对象）可以通过一个简单的赋值操作来分解为单独的变量。唯一的要求就是变量的总数和结构必须与序列相吻合。如果元素的数量不匹配，会得到一个错误提示。 data = [ &#39;ACME&#39;, 50, 91.1, (2012, 12, 21) ] name, shares, price, date = data date ## (2012, 12, 21) 星号解压语法是专门为解压不确定个数或任意个数元素的可迭代对象而设计的。 record = (&#39;ACME&#39;, 50, 123.45, (12, 18, 2012)) name, *_, (*_, year) = record name; year ## &#39;ACME&#39; ## 2012 first, *middle, last = range(10) first; last ## 0 ## 9 5.6 排序 sorted函数可以从任意序列的元素返回一个新的排好序的列表，sorted函数可以接受和sort方法相同的参数。sorted 的使用语法是：sorted(iterable, key=None, reverse=False)。 sort 与 sorted 区别： - sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。 - list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。 sorted([7, 1, 2, 6, 0, 3, 2]) ## [0, 1, 2, 2, 3, 6, 7] example_list = [5, 0, 6, 1, 2, 7, 3, 4] sorted(example_list, key = lambda x: x*-1) # 倒序排序 ## [7, 6, 5, 4, 3, 2, 1, 0] sorted(example_list, reverse = True) # 倒序排序 ## [7, 6, 5, 4, 3, 2, 1, 0] array = [{&quot;age&quot;:20,&quot;name&quot;:&quot;a&quot;},{&quot;age&quot;:25,&quot;name&quot;:&quot;b&quot;},{&quot;age&quot;:10,&quot;name&quot;:&quot;c&quot;}] array = sorted(array, key = lambda x:x[&quot;age&quot;]) print(array) ## [{&#39;age&#39;: 10, &#39;name&#39;: &#39;c&#39;}, {&#39;age&#39;: 20, &#39;name&#39;: &#39;a&#39;}, {&#39;age&#39;: 25, &#39;name&#39;: &#39;b&#39;}] 5.6.1 多关键字排序 使用sort方法和sorted函数时，key可以是多个字段。 a=[&#39;delphi&#39;, &#39;Delphi&#39;, &#39;python&#39;, &#39;Python&#39;, &#39;c++&#39;, &#39;C++&#39;, &#39;c&#39;, &#39;C&#39;] #先按字符串长度升序排序，长度相同按字典序升序排序 sorted(a, key = lambda x:(len(x), x)) ## [&#39;C&#39;, &#39;c&#39;, &#39;C++&#39;, &#39;c++&#39;, &#39;Delphi&#39;, &#39;Python&#39;, &#39;delphi&#39;, &#39;python&#39;] #先按字符串长度降序排序，长度相同按字典序升序排序 sorted(a, key = lambda x:(-len(x), x)) ## [&#39;Delphi&#39;, &#39;Python&#39;, &#39;delphi&#39;, &#39;python&#39;, &#39;C++&#39;, &#39;c++&#39;, &#39;C&#39;, &#39;c&#39;] a=[[1,3],[3,2],[2,4],[1,2],[1,5],[2,5]] #先按第一个元素升序排序，第一个元素相同按第二个元素升序排序 sorted(a) ## [[1, 2], [1, 3], [1, 5], [2, 4], [2, 5], [3, 2]] #先按第一个元素升序排序，第一个元素相同则保持原来的顺序 a=[[1,3],[3,2],[2,4],[1,2],[1,5],[2,5]] sorted(a, key=lambda x:x[0]) # a.sort(key=lambda x:x[0]) ## [[1, 3], [1, 2], [1, 5], [2, 4], [2, 5], [3, 2]] #先按第二个元素升序排序，第二个元素相同按第一个元素降序排序 sorted(a, key=lambda x:(x[1],-x[0])) ## [[3, 2], [1, 2], [1, 3], [2, 4], [2, 5], [1, 5]] 字符串比较大小时，是按每个相应的字符的Unicode编码进行比较。ord() 函数是 chr() 函数（对于8位的ASCII字符串）或 unichr() 函数（对于Unicode对象）的配对函数，它以一个字符（长度为1的字符串）作为参数，返回对应的 ASCII 数值，或者 Unicode 数值。 id_num = ord(&#39;一&#39;) for i in range(5): ch = chr(id_num+i) print(ch, ord(ch)) ## 一 19968 ## 丁 19969 ## 丂 19970 ## 七 19971 ## 丄 19972 5.7 collections collections 模块提供了一些功能更完善的容器类型和工具。参考容器数据类型的官方文档。 5.7.1 deque 使用 deque(maxlen=N) 构造函数会新建一个固定大小的队列。当新的元素加入并且这个队列已满的时候，最老的元素会自动被移除掉。 from collections import deque q = deque([1,2,3,4], maxlen=4) print(q) ## deque([1, 2, 3, 4], maxlen=4) q.append(5); print(q) ## deque([2, 3, 4, 5], maxlen=4) q.appendleft(0); print(q) ## deque([0, 2, 3, 4], maxlen=4) pop()移去并且返回deque最右侧的一个元素。 popleft()移去并且返回deque最左侧的一个元素。rotate(n=1)向右循环移动 n 步，如果 n 是负数，就向左循环。 q.pop(); print(q) ## 4 ## deque([0, 2, 3], maxlen=4) q.rotate(1); print(q) ## deque([3, 0, 2], maxlen=4) 5.7.2 Counter Counter 对象是字典类型的一个子类（即一种特殊的字典类型），可以快速完成对可迭代对象的频次统计。 words = [ &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;, &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;not&#39;, &#39;around&#39;, &#39;the&#39;, &#39;eyes&#39;, &quot;don&#39;t&quot;, &#39;look&#39;, &#39;around&#39;, &#39;the&#39;, &#39;eyes&#39;, &#39;look&#39;, &#39;into&#39;, &#39;my&#39;, &#39;eyes&#39;, &quot;you&#39;re&quot;, &#39;under&#39; ] from collections import Counter word_counts = Counter(words) # 出现频率最高的3个单词 top_three = word_counts.most_common(3) print(top_three) ## [(&#39;eyes&#39;, 8), (&#39;the&#39;, 5), (&#39;look&#39;, 4)] Counter 对象可以接受任意的由可哈希（hashable）元素构成的序列对象作为输入。在底层实现上，一个 Counter 对象就是一个字典，将元素映射到它出现的次数上。 word_counts[&#39;not&#39;] ## 1 5.7.3 heapq heapq 模块提供了堆队列算法的实现，也称为优先队列算法。堆最有趣的特性在于最小的元素总是在根结点：heap[0]。 # 查找最大或最小的 N 个元素 import heapq nums = [1, 8, 2, 23, 7, -4, 18, 23, 42, 37, 2] print(heapq.nlargest(3, nums)) ## [42, 37, 23] print(heapq.nsmallest(3, nums)) ## [-4, 1, 2] 当要查找的元素个数相对整体比较小的时候，函数 nlargest() 和 nsmallest() 是很合适的。如果你仅仅想查找唯一的最小或最大（N=1）的元素的话，那么使用 min() 和 max() 函数会更快些。类似的，如果 N 的大小和集合大小接近的时候，通常先排序这个集合然后再使用切片操作会更快点（sorted(items)[:N] 或者是 sorted(items)[-N:]）。 5.7.4 OrderedDict 为了能控制一个字典中元素的顺序，你可以使用 OrderedDict 类。 在迭代操作的时候它会保持元素被插入时的顺序： from collections import OrderedDict d = OrderedDict() d[&#39;foo&#39;] = 1 d[&#39;bar&#39;] = 2 d[&#39;spam&#39;] = 3 for key in d: print(key, d[key]) ## foo 1 ## bar 2 ## spam 3 5.7.5 namedtuple namedtuple 为元组中的每个位置赋予一个含义，相比于元组它增加了按名称索引访问字段的能力。构造方法为：namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)。 其中field_names由字母，数字，下划线组成，但首字母不能是数字或下划线。 from collections import namedtuple Point = namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;]) p = Point(11, y=22) # instantiate with positional or keyword arguments p[0] + p[1] # indexable like the plain tuple ## 33 p.x + p.y # fields also accessible by name ## 33 p ## Point(x=11, y=22) t = [11, 22] Point._make(t) # 从存在的序列或迭代实例创建一个新实例 ## Point(x=11, y=22) p = Point(x=11, y=22) p._asdict() # 生成一个字典 ，将字段名称映射到它们对应的值 ## {&#39;x&#39;: 11, &#39;y&#39;: 22} 5.8 拷贝 如果为自定义函数的参数指定默认值，那么该默认值最好不要使用可变类型对象（列表、字典、集合等）。如果使用了可变类型，每次调用该函数时，使用的默认值都是内存中的同一地址的同一个对象。这就意味着：每次调用函数时如果修改了这个默认值参数，则该修改将一直保留在内存中，下一次调用该函数时会继续受到影响。 列表、字典等容器对象的 copy() 方法属于浅拷贝，如果该容器中的某些元素也是容器（即子容器），则这些子容器不会被复制，而只是将其地址复制过来。copy 模块中的 deepcopy() 方法属于深拷贝，比如 b=deepcopy(a) 可以将 a 容器乃至其内部各层子容器都复制一份，并赋值给 b 。 如果列表 a 内包含子列表 b，那么对 a 执行列表乘法比如 a*3 后，只是将子列表 b 的地址重复3份、作为新列表的3个元素。但这三个元素其实指向的仍然是子列表 b ，只要修改其中任何一个，所有元素都会受到影响。 "],["function.html", "Chapter 6 函数 6.1 函数参数 6.2 默认值 6.3 函数注解 6.4 返回多个值 6.5 错误和异常处理", " Chapter 6 函数 函数是Python中最主要也是最重要的代码组织和复用手段。作为最重要的原则，如果你要重复使用相同或非常类似的代码，就需要写一个函数。函数代码块以 def 关键字声明，后接函数标识符名称和圆括号 ()。任何传入参数2和自变量必须放在圆括号中间。函数的第一行语句可以选择性地使用文档字符串——用于存放函数说明。return关键字返回结果结束函数。同时拥有多条return语句也是可以的。如果到达函数末尾时没有遇到任何一条return语句，则返回None。 def my_function(x, y, z=1.5): &quot;something about the function&quot; if z &gt; 1: return z * (x + y) else: return z / (x + y) 6.1 函数参数 函数可以有一些位置参数（positional）和一些关键字参数（keyword）。关键字参数通常用于指定默认值或可选参数。在上面的函数中，x和y是位置参数，而z则是关键字参数。也就是说，该函数可以下面这两种方式进行调用： my_function(5, 6, z=0.7) ## 0.06363636363636363 my_function(3.14, 7, 3.5) ## 35.49 my_function(10, 20) ## 45.0 函数参数的主要限制在于：关键字参数必须位于位置参数（如果有的话）之后。传递的所有关键字参数必须与函数接受的其中一个参数匹配，它们的顺序并不重要。不能对同一个参数多次赋值。你可以任何顺序指定关键字参数。也就是说，你不用死记硬背关键字参数的顺序，只要记得它们的名字就可以了。注意：也可以用关键字传递位置参数，这种写法可以提高可读性。前面的例子，也可以写为： my_function(x=5, y=6, z=7) my_function(y=6, x=5, z=7) *name参数可以接受任意数量的位置参数，并转换为一个元组；**name参数可以接受任意数量的关键字参数，并转换为一个字典。*name参数前面只能是位置参数，后面只能是关键字参数或者**name参数，*name必须出现在**name之前，**name参数必须是函数的最后一个参数。 def myfun(kind, *arguments, **keywords): statements ...... def fun(x, *args, y): print(f&quot;args = {args}&quot;) # 正确的调用方式： fun(1,2,3,4, y = 1) # fun(1,2,3,4,1)是错的 ## args = (2, 3, 4) 在这个例子中，y 只能是关键字参数，必须以y=1形式传入。 如果一个参数具有默认值，所有随后的参数直到* 也必须具有默认值。所以下面的函数定义语句会报错。 def funx(a, b = 2, c): print(a+b+c) 6.1.1 强制位置参数和强制关键字参数 函数形参语法中，有两个符号（/和*）可以用来强制分开位置参数、关键字参数与其他参数。位于/之前的是强制位置参数(Positional-Only Parameters)，位于*之后的只能是强制关键字参数（Keyword-Only Arguments），/与*之间可以是位置形参或关键字形参。 def f(a, b, /, c, d, *, e, f): print(a, b, c, d, e, f) f(10, 20, 30, d=40, e=50, f=60) # 以下都错: # f(10, b=20, c=30, d=40, e=50, f=60) # b 不能使用关键字参数的形式 # f(10, 20, 30, 40, 50, f=60) # e 必须使用关键字参数的形式 ## 10 20 30 40 50 60 6.2 默认值 重要警告：默认值只会执行一次。 执行函数定义时，从左到右计算默认参数值。这意味着该表达式只在函数定义的时候求一次值，以后每次调用使用相同的“提前计算好的”值。Python中向函数传递参数只能是引用传递，表示把它的内存地址传进去了。这条规则在默认值为可变对象（列表、字典以及大多数类实例）时很重要。如果函数修改了该对象时，默认值也将被修改。比如，下面的函数会存储在后续调用中传递给它的参数： def f(a, L=[]): L.append(a) return L f(1) ## [1] f(2) ## [1, 2] 如果你不想在后续调用之间共享默认值，可以使用None作为默认值，并在函数体中明确测试它： def f(a, L=None): if L is None: L = [] L.append(a) return L 6.3 函数注解 函数注解（Function Annotations）是用户自定义函数的参数和输出数据的元数据信息，它是可选的。注解以字典的形式存放在函数的 __annotations__ 属性中，并且不会影响函数的任何其他部分。形参标注的定义方式是在形参名后加冒号，后面跟一个表达式，该表达式会被求值为标注的值。返回值标注的定义方式是在括号和冒号之间加上 -&gt;，后面跟一个表达式。 函数注解只不过是在编译时将任意 Python 表达式与函数的各个部分相关联的一种方式。就其本身而言，Python 没有给注解附加任何特定的含义或意义。但是可以让 IDE 知道函数期望和返回的数据类型。 下面是一个示例: def f(ham: str, eggs: str = &#39;eggs&#39;) -&gt; str: print(&quot;Annotations:&quot;, f.__annotations__) print(&quot;Arguments:&quot;, ham, eggs) return ham + &#39; and &#39; + eggs f(&#39;spam&#39;) ## Annotations: {&#39;ham&#39;: &lt;class &#39;str&#39;&gt;, &#39;eggs&#39;: &lt;class &#39;str&#39;&gt;, &#39;return&#39;: &lt;class &#39;str&#39;&gt;} ## Arguments: spam eggs ## &#39;spam and eggs&#39; 6.4 返回多个值 函数可以返回多个值。下面是一个简单的例子： def f(): a = 5 b = 6 c = 7 return a, b, c a, b, c = f() 该函数其实只返回一个元组，该元组被解包到各个结果变量中。在上面的例子中，我们还可以这样写：output = f()，这里的output将会是一个三元元组。此外，还有一种非常实用的多值返回方式——返回字典： def f(): a = 5 b = 6 c = 7 return {&#39;a&#39; : a, &#39;b&#39; : b, &#39;c&#39; : c} 6.5 错误和异常处理 优雅地处理Python的错误和异常是构建健壮程序的重要部分。在数据分析中，许多函数函数只用于部分输入。例如，Python的float函数可以将字符串转换成浮点数，但输入有误时，有ValueError错误。假如想优雅地处理float的错误，让它返回输入值。我们可以写一个函数，在try/except中调用float： def attempt_float(x): try: return float(x) except: return x attempt_float((1,2)) ## (1, 2) 当float(x)抛出异常时，才会执行except的部分。你可能注意到float抛出的异常不仅是ValueError： In [202]: float((1, 2)) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-202-842079ebb635&gt; in &lt;module&gt;() ----&gt; 1 float((1, 2)) TypeError: float() argument must be a string or a number, not &#39;tuple&#39; 你可能只想处理ValueError，TypeError错误（输入不是字符串或数值）可能是合理的bug。可以写一个异常类型： def attempt_float(x): try: return float(x) except ValueError: return x 可以用元组包含多个异常： def attempt_float(x): try: return float(x) except (TypeError, ValueError): return x 某些情况下，你可能不想抑制异常，你想无论try部分的代码是否成功，都执行一段代码，这时可以使用finally： f = open(path, &#39;w&#39;) try: write_to_file(f) finally: f.close() The term parameter (sometimes called formal parameter) is often used to refer to the variable as found in the function definition, while argument (sometimes called actual parameter) refers to the actual input supplied at function call.↩︎ "],["reg-expr.html", "Chapter 7 字符串与正则表达式 7.1 字符串编码方案 7.2 字符编码检测 7.3 字节 7.4 正则表达式 7.5 two", " Chapter 7 字符串与正则表达式 7.1 字符串编码方案 在计算机内部，字符都需要转换为对应的数字。这种转换规则（比如指定将 ‘A’ 转换为 65 ）就是“编码方案”。目前使用最广泛的基本编码方案是 ASCII 编码。该方案包含英文大小写字符、数字字符以及加减乘除等常用符号。 比较两个字符的大小，其实就是比较这两个字符的编码数字大小。所以在ASCII编码下，‘A’ &lt; ‘a’ ，因为二者的码值分别为 65 和 97 。同理，‘1’ &lt; ‘A’ 也是正确的，因为二者的码值分别是 49 和 65 。对两个字符串比较大小时，Python首先比较二者的第一位字符，如果能够分出大小，则停止比较并将其作为最终结果；而如果第一个字符相同，则比较第二个字符，如此逐位比较。假如在没有比较出结果时、其中一个字符串就已经结束，则判定这个比较短的字符串小于更长的另一个字符串。 使用 ord 函数可以获得一个字符的编码数字（基于当前默认编码方案），而使用 chr 函数则可以指定一个编码数字、并返回该编码所对应的字符。 ASCII 表中位于 0~31 之间的字符，都是用于控制文本格式或针对计算机通讯等操作发出特殊指令，所以无法像普通文字一样显示在屏幕上。因此这些字符被称为“控制字符”、“非打印字符”或“不可显示字符”。其中10号字符（换行）最为常用。在 Dos 和 Windows 系统中，习惯上将 13 号字符（回车）和 10 号字符（换行）放在一起，共同表示一次换行。而在 Linux、Unix 以及 Mac OS 等系统中，则只使用 10 号字符表示换行。尽管如此，只使用 10 号字符换行的文本文件也能被大多数 Windows 下的编辑器正常读取。 为了在字符串中表示一些特殊字符（比如换行），Python 定义了一些 “转义字符”，即使用反斜线  和若干个特定字符组合在一起，表达一个含义。比如使用 代表换行。如果需要在字符串中表示引号，可以将其写为转义字符 ' 或 \" ，以免与最外层表示字符串起止的引号混淆。如果需要在字符串中表示反斜线  ，可以使用转义字符 \\ ，从而将反斜线的 “转义标识符” 功能转变为 “普通反斜线” 。 标准ASCII编码中使用一个字节保存一个字符，而一个字节（8位二进制）只能容纳256个数字，所以无法为中文等语言文字提供编码。 对于无法使用 ASC 编码的语言，相关国家的标准组织分别提出了自己的扩展编码方案，使用多个字节保存一个字符。典型如中国的 GB 系列、日本的 Shift-JIS 等。GB系列编码的最新版本是 GB18030，完全兼容 GB2312 并基本兼容 GBK。所以在不得不使用 GB2312 的场合，建议尽量使用 GB18030 代替它（除非所使用的操作系统等软件不支持GB18030）。 7.2 字符编码检测 如果我们知道一个文本文件的编码方案，我们可以指定读取的’encoding’选项直接读取： with open(&#39;jp_str.txt&#39;, &#39;r&#39; , encoding= &#39;UTF-8&#39;) as f: b = f.readlines() print(b) ## [&#39;あのねせかいはじつはつながっているんだって\\n&#39;, &#39;だからたとえはなれてしまってもみんなひとりじゃない\\n&#39;, &#39;たいせつなひととはいつまでもずっとどこかでつながっているのさ&#39;] 如果不知道这个文件的编码方案，可能会遇到乱码或读取错误的问题。第三方模块 chardet 可以自动检测字符编码的类型。使用过程如下： 1. 使用 open(文件名, ‘rb’ ) 以二进制方式打开文件； 2. 使用 b = f.read() 将文件内容全部读入字节流对象 b； 3. 使用 chardet.detect( b ) 可以得到一个字典，其中键 ‘encoding’ 对应的值就是 chardet 猜测的编码名称，‘confidence’ 键对应的是该猜测的可靠程度（置信度）。 应用样例如下： import chardet with open(&#39;jp_str.txt&#39;, &#39;rb&#39;) as f: b = f.read() e = chardet.detect(b) print(e) s = b.decode(e.get(&#39;encoding&#39;)) print(s) ## {&#39;encoding&#39;: &#39;utf-8&#39;, &#39;confidence&#39;: 0.99, &#39;language&#39;: &#39;&#39;} ## あのねせかいはじつはつながっているんだって ## だからたとえはなれてしまってもみんなひとりじゃない ## たいせつなひととはいつまでもずっとどこかでつながっているのさ 如果想让 chardet 判断出某段文本数据的编码名称，必须将该文本的原始二进制形式（即字节流）交给chardet的detect 方法，以便其观察数值特征和统计分析。在 Python 中，存储原始字节信息需要使用 bytes 对象。当使用 open(文件名, ‘r’) 读取文件时，Python会自动按照操作系统当前的默认编码方案、将硬盘上该文件的二进制数据解码为字符串，因而并没有得到其原始的字节数值、无法交给 chardet 进行检测。所以需要使用 open(文件名, ‘rb’) 的方式，指定以二进制方式读取文件，不经过自动编码转换。 如果将 open 函数的读写模式参数指定为 ‘rb’ 或 ‘wb’ ，则代表 “二进制读写” ，不会经过自动编码转换。此时不能再使用 f.readline() 方法读取文件内容，而应使用 b=f.read() 或 f.write(b) 方法。前者可以将文件全部内容的原始字节数值读入到一个 bytes 对象，后者则可以将一个 bytes 对象中的全部字节写入文件。此外，也可以通过 b=f.read(5) 的形式，指定从文件中只读取 5 个字节放入 b 。 bytes对象是一种由整数构成的序列（Sequence），因而与列表、字符串具有相似的用法，都可以使用下标和切片形式访问、使用 for 循环遍历。如果直接用 print 将 bytes 对象打印在屏幕上，Python则会自动将其中的所有数据以16进制数字字符串（如 ）的形式显示，以方便阅读。 7.3 字节 字节（bytes）是一种比特流，它的存在形式是01010001110这种01组合。它必须有一个编码方式，使得它变成有意义的比特流，而不是一堆晦涩难懂的数字。 bytes只负责以字节序列的形式（二进制形式）来存储数据，至于这些数据到底表示什么内容（字符串、数字、图片、音频等），完全由程序的解析方式决定。如果采用合适的字符编码方式（字符集），字节串可以恢复成字符串；反之亦然，字符串也可以转换成字节串。bytes 类型的数据非常适合在互联网上传输，可以用于网络通信编程；bytes 也可以用来存储图片、音频、视频等二进制格式的文件。 字符串和 bytes 存在着千丝万缕的联系。字符串类有一个encode()方法，它是从字符串向比特流的编码过程；反之，bytes类恰好有个decode()方法，它是从比特流向字符串解码的过程。 a = &quot;中文&quot; b = a.encode(encoding = &#39;UTF-8&#39;) b.decode(encoding = &#39;UTF-8&#39;) ## &#39;中文&#39; 或者： b = bytes(a, encoding = &#39;UTF-8&#39;) type(b) ## &lt;class &#39;bytes&#39;&gt; str(b, encoding = &#39;UTF-8&#39;) ## &#39;中文&#39; 对于任何来源的文本数据（文本文件、网络网页、数据库 ……），如果发现乱码，都可以用下面的思路解决： 使用字节流方式读取该来源，比如 open(文件名,‘rb’) ，将原始字节数据存入一个bytes对象； 将该 bytes 对象交给 chardet 等工具，获取最可能的编码名称； 调用该 bytes 对象的 decode 方法，按照获取的编码名称将其转换为字符串显示。 7.4 正则表达式 正则表达式可以被看作一种 “描述语言” 的语言。通过正则表达式，我们可以定义一个“规则”或“模式”，然后在文本中匹配所有符合该规则的字符串。 7.4.1 one 正则表达式模式在线图示网站：https://regexper.com/ 正则表达式详细表：http://web.suda.edu.cn/hejun/chapter8/regular_expression_table.html https://tool.oschina.net/uploads/apidocs/jquery/regexp.html https://regex101.com/ 7.4.2 example import re s1 = &#39;&#39;&#39;第一回 第二回 第三回 第四回五回 &#39;&#39;&#39; x = re.findall(&quot;第(.?)回&quot;, s1) print(x) ## [&#39;一&#39;, &#39;二&#39;, &#39;三&#39;, &#39;四&#39;] s2 = &quot;《三体》第二部《黑暗森林》作者&quot; x = re.findall(&#39;《.*?》&#39;, s2) print(x) ## [&#39;《三体》&#39;, &#39;《黑暗森林》&#39;] 7.5 two "],["module.html", "Chapter 8 模块 8.1 模块定义和使用 8.2 以脚本的方式执行模块 8.3 编译好的模块 8.4 标准模块 8.5 dir()函数 8.6 包 8.7 从包中导入 * 8.8 命名空间和作用域 8.9 闭包", " Chapter 8 模块 8.1 模块定义和使用 模块是一个包含Python定义和声明的文件。文件名就是模块名后跟文件后缀 .py。在一个模块内部，模块名（作为一个字符串）可以通过全局变量 __name__ 的值获得。例如，使用在当前目录下创建一个名为 fibo.py 的文件，文件中含有以下内容： # fibo.py def fib(n): a, b = 0, 1 while a &lt; n: print(a, end=&#39; &#39;) a, b = b, a+b print() def fib2(n): result = [] a, b = 0, 1 while a &lt; n: result.append(a) a, b = b, a+b return result 导入该模块： import fibo 模块名fibo被导入到当前符号表中，但是fibo中定义的函数名称不会直接导入当前工作表内。可以用模块名访问这些函数： fibo.fib(50) fibo.__name__ #&#39;fibo&#39; 如果你想经常使用某个函数，你可以把它赋值给一个本地名称: myfib = fibo.fib 模块可以包含可执行语句以及已定义的函数。这些语句通常用于初始化模块。只有在导入语句中第一次遇到模块名称时，才会执行。如果文件以脚本的方式执行，它们也会运行。每个模块都有自己的私有符号表，它被定义在模块中的所有函数当作全局符号表一样使用。 模块中可以导入其它模块。一般来说，习惯性地将所有 import 语句放在模块（或脚本）的开头，但这不是必须的。被导入的模块的名字存放在导入模块的全局符号表中。 另外有一种import语句的变种，可以从一个模块直接将名称导入到当前符号表中。例如： from fibo import fib, fib2 一般情况下不建议使用from fibo import *这种导入方式，因为它会引入一系列未知的名称到解释器中，这很可能覆盖你已经定义的一些东西。 使用as关键词，你可以给导入的名称重命名： from fibo import fib as fun1, fib2 as fun2 8.2 以脚本的方式执行模块 一个 Python 源码文件除了可以被直接运行外，还可以作为模块（也就是库）被导入。不管是导入还是直接运行，最顶层的代码都会被运行（Python 用缩进来区分代码层次）。__main__ 是顶层代码执行的作用域的名称。模块的 __name__ 在通过标准输入、脚本文件或是交互式命令读入的时候会等于 __main__。 在命令行窗口中，可以使用python fibo.py &lt;arguments&gt;执行模块里的代码。在IPython中，可以使用%run fibo.py &lt;arguments&gt;执行模块里的代码，这同时会将模块中定义的函数导入当前符号表中。 模块可以通过检查自己的 __name__ 来得知是否运行在 main 作用域中，这使得模块可以在作为脚本或是通过 python -m3 运行时条件性地执行一些代码，而在被 import 时不会执行。 实现方式是在模块中添加if __name__ == '__main__' 代码块： if __name__ == &quot;__main__&quot;: import sys fib(int(sys.argv[1])) 简单的理解就是： 如果模块是被直接运行的，则代码块被运行，如果模块是被导入的，则代码块不被运行。4对软件包来说，通过加入 __main__.py 模块可以达到同样的效果，当使用 -m 运行模块时，其中的代码会被执行。 8.3 编译好的模块 为了加快加载模块的速度，Python在__pycache__目录下缓存每个模块编译好的版本，名字为module.version.pyc，其中version表示编译好的文件的格式；它一般包含Python的版本号。例如，在Python 3.3中，spam.py编译好的版本将缓存为 __pycache__/spam.cpython-33.pyc。这种命名约定允许由不同发布和不同版本的Python编译的模块同时存在。 Python会检查源文件和编译好的版本的修改日期，来查看它是否过期以及需要重新编译。这是完全自动化的过程。同时，编译后的模块是跨平台的，所以同一个库可以在不同架构的系统之间共享。 Python 在两种情况下不检查缓存。第一，它会始终重新编译而且不保存直接从命令行加载的模块。第二，如果没有源模块，它不会检查缓存。若要支持没有源文件（只有编译版）的发布，编译后的模块必须在源目录下，并且必须没有源模块。 8.4 标准模块 Python附带了一个标准模块库，有单独的Python库参考手册。有一些模块内置于解释器中；它们提供对不属于语言核心但仍然内置的操作的访问，以提高效率或提供对系统调用等操作系统原语的访问。这些模块的集合是一个配置选项，它也取决于底层平台。例如，winreg 模块只在Windows操作系统上提供。一个特别值得注意的模块 sys，它被内嵌到每一个Python解释器中。变量 sys.ps1 和 sys.ps2 定义了主提示符和辅助提示符使用的字符串: import sys sys.ps1 sys.ps2 # 注意：只有在交互式模式中，这两个变量才有定义 8.5 dir()函数 内置函数 dir() 用来找出模块中定义了哪些名称。它返回一个排好序的字符串列表： dir(fibo) # [&#39;__name__&#39;, &#39;fib&#39;, &#39;fib2&#39;] 如果不带参数， dir() 列出当前环境中已定义的名称。dir()不会列出内置的函数和变量的名称。 8.6 包 包是一种通过用“带点号的模块名”来构造 Python 模块命名空间的方法。 例如，模块名 A.B 表示 A 包中名为 B 的子模块。正如模块的使用使得不同模块的作者不必担心彼此的全局变量名称重名一样，使用加点的模块名可以使得 NumPy 或 Pillow 等多模块软件包的作者不必担心彼此的模块名称重名。 当使用 from package import item 时，item可以是包的子模块（或子包），也可以是包中定义的其他名称，如函数，类或变量。 import 语句首先测试是否在包中定义了item；如果没有，它假定它是一个模块并尝试加载它。如果找不到它，则引发 ImportError 异常。 相反，当使用 import item.subitem.subsubitem 这样的语法时，除了最后一项之外的每一项都必须是一个包；最后一项可以是模块或包，但不能是前一项中定义的类或函数或变量。 可以简单的将包看作是一个文件系统的目录，将模块看作是目录中的代码文件。包是一种特殊的模块。需要记住的是，所有的包都是模块，但不是所有的模块都是包。包中子包和模块都有 __path__ 属性，具体地说，任何包含 __path__ 属性的模块被认为是包。 8.7 从包中导入 * 首先，from pkg import *是不建议的导入方法。如果要使用这种方法，一般应该在__init__.py中提供包的显式索引。 如果一个包的 __init__.py 代码定义了一个名为 __all__ 的列表，它会被视为在遇到 from package import * 时应该导入的模块名列表。如果包作者认为从他的包中导入 * 的操作没有必要被使用，也可以决定不支持此列表。 8.8 命名空间和作用域 命名空间（namespace）是 Python 最核心的内容。Python的名字实际上是一个字符串对象，它和所指向的目标对象一起在命名空间中构成一项 {name: object} 关联。所以命名空间是从名字到对象的一个映射(a mapping from name to objects) 。 大部分命名空间都是按Python中的字典来实现的。名字的作用仅仅是在某个时刻与名字空间中的某个对象进行关联。其本身不包含目标对象的任何信息，只有通过对象头部的类型指针才能获知其具体类型，进而查找其相关成员数据。正因为名字的弱类型特征，我们可以在运行期间随时将其关联到任何类型对象。 在程序执行期间，可能（其实是肯定）会有多个命名空间同时存在。不同命名空间的创建/销毁时间也不同。此外，两个不同命名空间中的两个相同名字的变量之间没有任何联系。 一个作用域(Scope)是一个命名空间可直接访问的 Python 程序的文本区域。这里的 “可直接访问” 意味着对名称的非限定引用会尝试在命名空间中查找名称。 Local(innermost): 包含局部变量。比如一个函数/方法内部。 Enclosing: 包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，内层函数可能搜索外层函数的namespace，但该namespace对内层函数而言既非局部也非全局。 Global(next-to-last): 当前脚本的最外层。比如当前模块的全局变量。 Built-in(outtermost): Python __builtin__ 模块。包含了内建的变量/关键字等。 作用域的搜索顺序是：Local -&gt; Enclosing -&gt; Global -&gt; Built-in def scope_test(): def do_local(): spam = &quot;local spam&quot; def do_nonlocal(): nonlocal spam spam = &quot;nonlocal spam&quot; def do_global(): global spam spam = &quot;global spam&quot; spam = &quot;test spam&quot; do_local() print(&quot;After local assignment:&quot;, spam) do_nonlocal() print(&quot;After nonlocal assignment:&quot;, spam) do_global() print(&quot;After global assignment:&quot;, spam) scope_test() ## After local assignment: test spam ## After nonlocal assignment: nonlocal spam ## After global assignment: nonlocal spam print(&quot;In global scope:&quot;, spam) ## In global scope: global spam 可以看到，局部赋值不会改变 scope_test 对 spam 的绑定（enclosing）。 nonlocal 赋值会改变 scope_test 对 spam 的绑定，而 global 赋值会改变模块层级的绑定。 def outer(): a = 0 b = 1 def inner(): print(a) print(b) # b += 1 # A b = 4 # B inner() outer() # UnboundLocalError: local variable &#39;b&#39; referenced before assignment Python解释器执行到 inner() 中的 print b 时，发现有个变量 b，在当前作用域(local)中无法找到该变量。它继续尝试把整块代码解释完，b 是属于 inner() 作用域的，既然对变量 b 的赋值（声明）发生在 print 语句之后， print 语句执行时变量 b 是还未被声明的，于是抛出错误：变量在赋值前就被引用。在这个例子中，只有A语句没有B语句也会导致同样的结果。 因为b没有被声明为非本地变量(nonlocal)，在inner()的局部空间中b是只读的（尝试写入b的赋值语句只会在最内层作用域中创建一个新的局部变量，而同名的外部变量保持不变）。 for i in range(3): print(i) ## 0 ## 1 ## 2 print(&quot;i =&quot;, i) ## i = 2 for 后面跟着的变量(target list)在循环结束后是不会被删除的，但如果 for 循环的序列为空，这些变量是完全不会被赋值的。 8.9 闭包 Python 的 -m 参数用于将一个模块或者包作为一个脚本运行，而 __main__.py 文件则相当于是一个包的“入口程序”。加上 -m 参数时 Python 会先将模块或者包导入，然后再执行。↩︎ 参考资料：Python 中的 if __name__ == __main__ 该如何理解↩︎ "],["OOP.html", "Chapter 9 Python 面向对象 9.1 术语简介 9.2 创建类 9.3 类对象 9.4 实例对象 9.5 方法对象 9.6 类和实例变量 9.7 Python内置类属性 9.8 补充说明 9.9 类的继承 9.10 私有变量 9.11 元类", " Chapter 9 Python 面向对象 先有类型 (class)，再有对象(object)。Python 中的一切都是对象，包括类型。每个对象都有明确的类型。 9.1 术语简介 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 类变量：类的所有实例共享的属性和方法。类变量定义在类中且在函数体之外。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：独属于每个实例的属性。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。 实例化：创建一个类的实例，类的具体对象。 方法：类中定义的函数。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 9.2 创建类 类(classes)定义的形式如下： class ClassName: &#39;类的帮助信息&#39; &lt;statement-1&gt; ... &lt;statement-N&gt; 类定义与函数定义 (def 语句) 一样必须被执行才会起作用。当进入类定义时，将创建一个新的命名空间，并将其用作局部作用域。因此，所有对局部变量的赋值都是在这个新命名空间之内。 9.3 类对象 类对象支持两种操作：属性引用和实例化。 类对象的属性引用使用 Python 中所有属性引用所使用的标准语法: obj.name。 有效的属性名称是类对象被创建时存在于类命名空间中的所有名称。 因此，如果类定义是这样的: class MyClass: &quot;&quot;&quot;A simple example class&quot;&quot;&quot; i = 12345 def f(self): return &#39;hello world&#39; 那么 MyClass.i 和 MyClass.f 就是有效的属性引用，将分别返回一个整数和一个函数对象。 类属性也可以被赋值，因此可以通过赋值来更改 MyClass.i 的值。 __doc__ 也是一个有效的属性，将返回所属类的文档字符串：“A simple example class”。 类的实例化使用函数表示法，可以假装类对象就是会返回一个新的类实例的函数。 举例来说：x = MyClass()，将创建MyClass类的新实例并将此对象分配给局部变量x。 如果一个类定义了 __init__() 方法，创建了这个类的实例时就会调用该方法，可以看成是类实例的初始化操作。 当然，__init__() 方法还可以有额外参数以实现更高灵活性。在这种情况下，提供给类实例化运算符的参数将被传递给 __init__()。 例如： class Complex: def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpart x = Complex(3.0, -4.5) x.r, x.i ## (3.0, -4.5) 9.4 实例对象 实例对象(Instance Objects)支持的唯一操作是属性引用。有效的属性名称有两种：数据属性和方法。数据属性不需要声明；像局部变量一样，它们将在第一次被赋值时产生。另一类实例属性是方法，方法是从属于对象的函数。（在 Python中，方法这个术语并不是类实例所特有的，其他对象也可以有方法。） 9.5 方法对象 x.f 是一个方法对象，它可以被保存起来以后再调用。 x = MyClass() x.f() ## &#39;hello world&#39; xf = x.f xf() ## &#39;hello world&#39; MyClass.f() # TypeError: f() missing 1 required positional argument: &#39;self&#39; 可以看到， x.f()没有报错，但 MyClass.f() 报错了。所以 x.f 与 MyClass.f 并不是一回事，它们是一个方法对象，一个是函数对象。 方法的特殊之处就在于实例对象会作为函数的第一个参数被传入。 在我们的示例中，调用 x.f() 其实就相当于 MyClass.f(x)。总之，调用一个具有n个参数的实例方法就相当于调用n+1个参数的对应函数，增加的这个参数值就是方法所属的实例对象，位置在其他参数之前。 9.6 类和实例变量 一般来说，实例变量(instance variable)是唯一属于每个实例的数据，而类变量(class variable)则是类的所有实例共享的属性和方法： class Dog: kind = &#39;canine&#39; # class variable shared by all instances def __init__(self, name): self.name = name # instance variable unique to each instance d = Dog(&#39;Fido&#39;) e = Dog(&#39;Buddy&#39;) d.kind, e.kind # shared by all dogs ## (&#39;canine&#39;, &#39;canine&#39;) d.name # unique to d ## &#39;Fido&#39; e.name # unique to e ## &#39;Buddy&#39; 9.7 Python内置类属性 __dict__ : 类的属性（包含一个字典，由类的数据属性组成） __doc__ :类的文档字符串 __name__: 类名 __module__: 类定义所在的模块（类的全名是__main__.className，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod） __bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组） class Employee: &#39;base class&#39; empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print(&quot;Total Employee %d&quot; % Employee.empCount) def displayEmployee(self): print(&quot;Name : &quot;, self.name, &quot;, Salary: &quot;, self.salary) print(&quot;Employee.__doc__:&quot;, Employee.__doc__) ## Employee.__doc__: base class print(&quot;Employee.__name__:&quot;, Employee.__name__) ## Employee.__name__: Employee print(&quot;Employee.__module__:&quot;, Employee.__module__) ## Employee.__module__: __main__ print(&quot;Employee.__bases__:&quot;, Employee.__bases__) ## Employee.__bases__: (&lt;class &#39;object&#39;&gt;,) print(&quot;Employee.__dict__:&quot;, Employee.__dict__) ## Employee.__dict__: {&#39;__module__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: &#39;base class&#39;, &#39;empCount&#39;: 0, &#39;__init__&#39;: &lt;function Employee.__init__ at 0x00000000266B63A0&gt;, &#39;displayCount&#39;: &lt;function Employee.displayCount at 0x00000000266B6430&gt;, &#39;displayEmployee&#39;: &lt;function Employee.displayEmployee at 0x00000000266B64C0&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;Employee&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;Employee&#39; objects&gt;} 9.8 补充说明 数据属性会覆盖同名的方法属性，这在大型程序中可能带来极难发现的 bug。为了避免意外的命名冲突，使用一些约定来减少冲突的几率是明智的。可能的约定包括：方法属性名称的首字母大写，数据属性名称的前缀使用一个唯一的小写的字符串（也许只是一个下划线），或者方法使用动词而数据属性使用名词。 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称，按照惯例它的名称是 self。这仅仅是一个约定， self 对 Python 而言绝对没有任何特殊含义。但是如果不遵循这个约定，对其他的 Python 程序员而言你的代码可读性就会变差，而且有些类 查看器程序也可能是遵循此约定编写的。 class Test: def prt(self): print(self) print(self.__class__) t = Test() t.prt() ## &lt;__main__.Test object at 0x00000000266C01F0&gt; ## &lt;class &#39;__main__.Test&#39;&gt; 从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.__class__ 则指向类。 类属性的任何函数对象都为那个类的实例定义了一个方法。函数定义代码不一定非得定义在类中：也可以将一个函数对象赋值给类中的一个局部变量。例如： # Function defined outside the class def f1(self, x, y): return min(x, x+y) class C: f = f1 def g(self): return &#39;hello world&#39; h = g 现在 f、g 和 h 都是 C类中的函数对象，因此它们都是 C 的实例的方法 —— h 完全等同于 g 。请注意，这种做法通常只会使阅读程序的人产生困惑。 方法可以通过使用 self 参数的方法属性，调用其他方法： class Bag: def __init__(self): self.data = [] def add(self, x): self.data.append(x) def addtwice(self, x): self.add(x) self.add(x) 方法可以像普通函数那样引用全局命名。与方法关联的全局作用域是包含这个方法的定义的模块（类）。（类本身永远不会作为全局作用域使用） 9.9 类的继承 面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。 通过继承创建的新类称为子类或派生类，被继承的类称为基类或父类。 class DerivedClassName(BaseClassName): &lt;statement-1&gt; ... &lt;statement-N&gt; 在python中继承中的一些特点： 如果在子类中需要父类的构造方法就需要显示的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看：Python 子类继承父类构造函数说明。 在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数。 Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。 如果在继承元组中列了一个以上的类，那么它就被称作”多重继承” 。 class Parent: parentAttr = 100 def __init__(self): print(&quot;Call the parent class constructor&quot;) def parentMethod(self): print(&#39;Call the parent class method&#39;) def setAttr(self, attr): Parent.parentAttr = attr def getAttr(self): print(&quot;Parent class attribute :&quot;, Parent.parentAttr) class Child(Parent): def __init__(self): print(&quot;Call subclass constructor&quot;) def childMethod(self): print(&#39;Call subclass method&#39;) c = Child() ## Call subclass constructor c.childMethod() ## Call subclass method c.parentMethod() ## Call the parent class method c.setAttr(200) c.getAttr() ## Parent class attribute : 200 派生类定义的执行过程和基类是相同的。在解析属性的引用时，如果在类中找不到请求的属性，搜索会在基类中继续。如果基类本身是由别的类派生而来，这个规则会递归应用。 派生类的实例化没有什么特殊之处： DerivedClassName() 创建类的一个新的实例。方法的引用按如下规则解析： 搜索对应的类的属性，必要时沿基类链逐级搜索，如果找到了函数对象这个方法引用就是合法的。 Python 有两个用于检查继承的函数： issubclass() 布尔函数，判断一个类是另一个类的子类或者子孙类，语法：issubclass(sub, sup) isinstance(obj, Class)布尔函数，如果obj是Class类的实例对象或者是一个Class子类的实例对象则返回true。 派生类可以重写基类中的方法。 class Parent: def myMethod(self): print(&#39;Call parent class method&#39;) class Child(Parent): def myMethod(self): print(&#39;Call subclass method&#39;) c = Child() c.myMethod() ## Call subclass method 派生类中的覆盖方法可能是想要扩充而不是简单的替代基类中的重名方法。有一个简单的方法可以直接调用基类方法：只要调用 BaseClassName.methodname(self, arguments)。 9.10 私有变量 Python中并不存在所谓只能在对象内部才能访问的“私有”实例变量。然而，有一项大多数 Python 代码都遵循的习惯：带有一个下划线前缀的名称（例如_spam ）应被视为非公开的 API 的一部分（无论是函数、 方法还是数据成员）。 由于存在一种合理的类私有成员使用场景（例如为了避免名称与子类所定义名称的冲突），Python 对这种机制提供了简单的支持，即所谓“名称重整” （name mangling）。__spam 形式的任何标识符（前面至少两个下划线，后面至多一个下划线）将被替换为 _classname__spam，其中 classname 为去除了前缀下划线的当前类名称。这种替换不考虑标识符的句法位置，只要它出现在类的定义内就会进行。 名称重整有利于子类重写父类的方法而不会破坏类内部的方法调用 class Mapping: def __init__(self, iterable): self.items_list = [] self.__update(iterable) def update(self, iterable): for item in iterable: self.items_list.append(item) __update = update # private copy of original update() method class MappingSubclass(Mapping): def update(self, keys, values): # provides new signature for update() # but does not break __init__() for item in zip(keys, values): self.items_list.append(item) 9.11 元类 在Python中，类也是对象（Classes are objects）。 class ObjectCreator: pass 会在内存中创造一个名为ObjectCreator的类对象。这个类对象具备创造对象的能力，同时它本身也是一个对象。它可以被赋值给别的变量，可以被复制，可以给它添加属性，可以作为函数参数传递。 print(ObjectCreator) ## &lt;class &#39;__main__.ObjectCreator&#39;&gt; def echo(o): print(o) echo(ObjectCreator) ## &lt;class &#39;__main__.ObjectCreator&#39;&gt; hasattr(ObjectCreator, &#39;new_attr&#39;) ## False ObjectCreator.new_attr = &#39;foo&#39; hasattr(ObjectCreator, &#39;new_attr&#39;) ## True ObjectCreator.new_attr ## &#39;foo&#39; ObjectCreatorMirror = ObjectCreator print(ObjectCreatorMirror()) ## &lt;__main__.ObjectCreator object at 0x00000000266CBE80&gt; 因为类是对象，所以你可以想对象一样动态地创建它们。 def choose_class(name): if name == &quot;foo&quot;: class Foo: pass return Foo else: class Bar: pass return Bar myclass = choose_class(&#39;foo&#39;) print(myclass) ## &lt;class &#39;__main__.choose_class.&lt;locals&gt;.Foo&#39;&gt; print(myclass()) ## &lt;__main__.choose_class.&lt;locals&gt;.Foo object at 0x00000000266CBEB0&gt; 因为类是对象，所以肯定可以由某些东西来创建。一种是使用关键词class，另一种是使用type函数手动创建。type函数常见的作用是查看对象的类型（type）。 type(1) ## &lt;class &#39;int&#39;&gt; type(&#39;1&#39;) ## &lt;class &#39;str&#39;&gt; type(ObjectCreator) ## &lt;class &#39;type&#39;&gt; type(ObjectCreator()) ## &lt;class &#39;__main__.ObjectCreator&#39;&gt; type可以按照以下方式定义类： type(name of the class, tuple of the parent class (for inheritance, can be empty), dictionary containing attributes names and values) 比如： MyShinyClass = type(&#39;MyShinyClass&#39;, (), {}) print(MyShinyClass) ## &lt;class &#39;__main__.MyShinyClass&#39;&gt; print(MyShinyClass()) ## &lt;__main__.MyShinyClass object at 0x00000000266CCEE0&gt; Foo = type(&#39;Foo&#39;, (MyShinyClass,), {&#39;bar&#39;:True}) #inherit from MyShinyClass Foo.bar ## True 元类是创建类的类。type就是Python中的元类。 age = 35 age.__class__ ## &lt;class &#39;int&#39;&gt; name = &#39;bob&#39; name.__class__ ## &lt;class &#39;str&#39;&gt; def foo(): pass foo.__class__ ## &lt;class &#39;function&#39;&gt; class bar: pass bar.__class__ # then ## &lt;class &#39;type&#39;&gt; age.__class__.__class__ ## &lt;class &#39;type&#39;&gt; name.__class__.__class__ ## &lt;class &#39;type&#39;&gt; foo.__class__.__class__ ## &lt;class &#39;type&#39;&gt; 参考资料： Python官方教程 第九章：类 Python3 面向对象 Python面向对象 一篇文章搞懂Python中的面向对象编程 Python3 迭代器与生成器 一篇文章搞懂Python中的函数式编程 What are metaclasses in Python ? "],["functional.html", "Chapter 10 函数式编程 10.1 函数也是对象 10.2 匿名（lambda）函数 10.3 柯里化 10.4 itertools模块 10.5 map 10.6 filter 10.7 reduce", " Chapter 10 函数式编程 10.1 函数也是对象 由于Python函数都是对象，因此，在其他语言中较难表达的一些设计思想在Python中就要简单很多了。假设我们有下面这样一个字符串数组，希望对其进行一些数据清理工作并执行一堆转换： states = [&#39; Alabama &#39;, &#39;Georgia!&#39;, &#39;Georgia&#39;, &#39;georgia&#39;, &#39;FlOrIda&#39;, &#39;south carolina##&#39;, &#39;West virginia?&#39;] 为了得到一组能用于分析工作的格式统一的字符串，需要做很多事情：去除空白符、删除各种标点符号、正确的大写格式等。做法之一是使用内建的字符串方法和正则表达式re模块： import re def clean_strings(strings): result = [] for value in strings: value = value.strip() value = re.sub(&#39;[!#?]&#39;, &#39;&#39;, value) value = value.title() result.append(value) return result 结果如下所示： clean_strings(states) ## [&#39;Alabama&#39;, &#39;Georgia&#39;, &#39;Georgia&#39;, &#39;Georgia&#39;, &#39;Florida&#39;, &#39;South Carolina&#39;, &#39;West Virginia&#39;] 其实还有另外一种不错的办法：将需要在一组给定字符串上执行的所有运算做成一个列表： def remove_punctuation(value): return re.sub(&#39;[!#?]&#39;, &#39;&#39;, value) clean_ops = [str.strip, remove_punctuation, str.title] def clean_strings(strings, ops): result = [] for value in strings: for function in ops: value = function(value) result.append(value) return result 然后我们就有了： clean_strings(states, clean_ops) ## [&#39;Alabama&#39;, &#39;Georgia&#39;, &#39;Georgia&#39;, &#39;Georgia&#39;, &#39;Florida&#39;, &#39;South Carolina&#39;, &#39;West Virginia&#39;] 这种多函数模式使你能在很高的层次上轻松修改字符串的转换方式。此时的clean_strings也更具可复用性！还可以将函数用作其他函数的参数，比如内置的map函数，它用于在一组数据上应用一个函数： for x in map(remove_punctuation, states): print(x) ## Alabama ## Georgia ## Georgia ## georgia ## FlOrIda ## south carolina ## West virginia 10.2 匿名（lambda）函数 Python支持一种被称为匿名的或lambda函数。lambda的主体是一个表达式，而不是一个代码块。它通过lambda关键字定义。 def short_function(x): return x * 2 equiv_anon = lambda x: x * 2 lambda 函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。lambda 匿名函数可以使用”关键字参数”进行参数传递： g = lambda x,y : x**2+y**2 g(2,3) ## 13 g(y=3, x=2) ## 13 lambda函数在数据分析工作中非常方便，因为你会发现很多数据转换函数都以函数作为参数的。直接传入lambda函数比编写完整函数声明要少输入很多字（也更清晰），甚至比将lambda函数赋值给一个变量还要少输入很多字。看看下面这个简单的例子： def apply_to_list(some_list, f): return [f(x) for x in some_list] ints = [4, 0, 1, 5, 6] apply_to_list(ints, lambda x: x * 2) ## [8, 0, 2, 10, 12] 虽然你可以直接编写[x*2 for x in ints]，但是这里我们可以非常轻松地传入一个自定义函数给apply_to_list函数。 再来看另外一个例子。假设有一组字符串，你想要根据各字符串不同字母的数量对其进行排序： strings = [&#39;foo&#39;, &#39;card&#39;, &#39;bar&#39;, &#39;aaaa&#39;, &#39;abab&#39;] 这里，我们可以传入一个lambda函数到列表的sort方法： strings.sort(key=lambda x: len(set(list(x)))) 笔记：lambda函数之所以会被称为匿名函数，与def声明的函数不同，原因之一就是这种函数对象本身是没有提供名称name属性。 10.3 柯里化 柯里化（currying）是一个有趣的计算机科学术语，它指的是通过“部分参数应用”（partial argument application）从现有函数派生出新函数的技术。例如，假设我们有一个执行两数相加的简单函数： def add_numbers(x, y): return x + y 通过这个函数，我们可以派生出一个新的只有一个参数的函数——add_five，它用于对其参数加5： add_five = lambda y: add_numbers(5, y) add_numbers的第二个参数称为“柯里化的”（curried）。这里没什么特别花哨的东西，因为我们其实就只是定义了一个可以调用现有函数的新函数而已。内置的functools模块可以用partial函数将此过程简化： from functools import partial add_five = partial(add_numbers, 5) 10.4 itertools模块 itertools模块中由一系列为高效循环而创建迭代器的函数。 10.4.1 无穷迭代器 迭代器 实参 结果 示例 count() start, [step] start, start+step, start+2*step, … count(10) –&gt; 10 11 12 13 14 … cycle() p p0, p1, … plast, p0, p1, … cycle(‘ABCD’) –&gt; A B C D A B C D … repeat() elem [,n] elem, elem, elem, … 重复无限次或n次 repeat(10, 3) –&gt; 10 10 10 10.4.2 根据最短输入序列长度停止的迭代器 迭代器 实参 结果 示例 accumulate() p [,func] p0, p0+p1, p0+p1+p2, … accumulate([1,2,3,4,5]) –&gt; 1 3 6 10 15 chain() p, q, … p0, p1, … plast, q0, q1, … chain(‘ABC,’ ‘DEF’) –&gt; A B C D E F chain.from_iterable() iterable – 可迭代对象 p0, p1, … plast, q0, q1, … chain.from_iterable([‘ABC,’ ‘DEF’]) –&gt; A B C D E F compress() data, selectors (d[0] if s[0]), (d[1] if s[1]), … compress(‘ABCDEF,’ [1,0,1,0,1,1]) –&gt; A C E F dropwhile() pred, seq seq[n], seq[n+1], … 从pred首次真值测试失败开始 dropwhile(lambda x: x&lt;5, [1,4,6,4,1]) –&gt; 6 4 1 filterfalse() pred, seq seq中pred(x)为假值的元素，x是seq中的元素。 filterfalse(lambda x: x%2, range(10)) –&gt; 0 2 4 6 8 groupby() iterable[, key] 根据key(v)值分组的迭代器 islice() seq, [start,] stop [, step] seq[start:stop:step]中的元素 islice(‘ABCDEFG,’ 2, None) –&gt; C D E F G starmap() func, seq func(seq[0]), func(seq[1]), … starmap(pow, [(2,5), (3,2), (10,3)]) –&gt; 32 9 1000 takewhile() pred, seq seq[0], seq[1], …, 直到pred真值测试失败 takewhile(lambda x: x&lt;5, [1,4,6,4,1]) –&gt; 1 4 tee() it, n it1, it2, … itn 将一个迭代器拆分为n个迭代器 zip_longest() p, q, … (p[0], q[0]), (p[1], q[1]), … zip_longest(‘ABCD,’ ‘xy,’ fillvalue=‘-’) –&gt; Ax By C- D- groupby可以接受任何序列和一个函数。它根据函数的返回值对序列中的连续元素进行分组。下面是一个例子： import itertools as itt first_letter = lambda x: x[0] names = [&#39;Alan&#39;, &#39;Adam&#39;, &#39;Wes&#39;, &#39;Will&#39;, &#39;Albert&#39;, &#39;Steven&#39;] for letter, names in itt.groupby(names, first_letter): print(letter, list(names)) ## A [&#39;Alan&#39;, &#39;Adam&#39;] ## W [&#39;Wes&#39;, &#39;Will&#39;] ## A [&#39;Albert&#39;] ## S [&#39;Steven&#39;] 10.4.3 排列组合迭代器 迭代器 实参 结果 product() p, q, … [repeat=1] 笛卡尔积，相当于嵌套的for循环 permutations() p[, r] 长度r元组，所有可能的排列，无重复元素 combinations() p, r 长度r元组，有序，无重复元素 combinations_with_replacement() p, r 长度r元组，有序，元素可重复 list(itt.product(&#39;ABCD&#39;, repeat=2)) ## [(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;A&#39;, &#39;D&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;D&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;D&#39;), (&#39;D&#39;, &#39;A&#39;), (&#39;D&#39;, &#39;B&#39;), (&#39;D&#39;, &#39;C&#39;), (&#39;D&#39;, &#39;D&#39;)] list(itt.permutations(&#39;ABCD&#39;, 2)) ## [(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;A&#39;, &#39;D&#39;), (&#39;B&#39;, &#39;A&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;D&#39;), (&#39;C&#39;, &#39;A&#39;), (&#39;C&#39;, &#39;B&#39;), (&#39;C&#39;, &#39;D&#39;), (&#39;D&#39;, &#39;A&#39;), (&#39;D&#39;, &#39;B&#39;), (&#39;D&#39;, &#39;C&#39;)] list(itt.combinations(&#39;ABCD&#39;, 2)) ## [(&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;A&#39;, &#39;D&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;D&#39;), (&#39;C&#39;, &#39;D&#39;)] list(itt.combinations_with_replacement(&#39;ABCD&#39;, 2)) ## [(&#39;A&#39;, &#39;A&#39;), (&#39;A&#39;, &#39;B&#39;), (&#39;A&#39;, &#39;C&#39;), (&#39;A&#39;, &#39;D&#39;), (&#39;B&#39;, &#39;B&#39;), (&#39;B&#39;, &#39;C&#39;), (&#39;B&#39;, &#39;D&#39;), (&#39;C&#39;, &#39;C&#39;), (&#39;C&#39;, &#39;D&#39;), (&#39;D&#39;, &#39;D&#39;)] 10.5 map map() 函数语法：map(function, iterable, …)，第一个参数 function 以 iterable 中的每一个元素调用 function 函数，返回包含全部 function 函数返回值的一个迭代器。如果函数有多个参数（iterable）, 但每个参数序列长度不一样, 会根据最少元素的序列进行。 list(map(lambda x: x.capitalize(), [&#39;cat&#39;, &#39;dog&#39;, &#39;cow&#39;])) # 如果提供了两个列表，函数会调用相同位置的列表元素对 ## [&#39;Cat&#39;, &#39;Dog&#39;, &#39;Cow&#39;] map(lambda x, y: x + y, [1, 3, 5, 7, 9], [2, 4, 6, 8, 10]) ## &lt;map object at 0x00000000266CC220&gt; 10.6 filter filter()用于过滤序列，过滤掉不符合条件的元素，返回符合条件的元素组成新列表。filter()的语法是filter(function, iterable)，其中function是一个判断函数。filter()可以转换为列表推导式。 even = lambda x: x%2 == 0 list(filter(even, range(11))) ## [0, 2, 4, 6, 8, 10] 请注意，filter()返回一个迭代器，因此需要调用内置类型list来构造给定迭代器的列表。 上面的列子转换成列表推导式如下： [x for x in range(11) if x%2 == 0] ## [0, 2, 4, 6, 8, 10] 10.7 reduce 从 Python 3 开始，reduce()已经从内置函数变成了functools模块函数。reduce()函数的语法是：reduce(function, iterable[, initial])，解释如下： function：有两个参数的函数，必需参数 iterable：tuple ，list ，dictionary，string等可迭代对象，必需参数 如果提供了 initial 参数，计算时它将被放在iterable的最前面，如果iterable是空的，它就是计算的默认结果值 from functools import reduce reduce(lambda x, y: x+y, [1,2,3,4,5]) ## 15 pairs = [(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)] reduce(lambda a, pair: a + pair[0], pairs, 0) ## 6 一个更简洁的解决方案是使用解包： pairs = [(1, &#39;a&#39;), (2, &#39;b&#39;), (3, &#39;c&#39;)] sum(x for x, _ in pairs) ## 6 "],["specialized-data-types.html", "Chapter 11 专门数据类型 11.1 日期和时间", " Chapter 11 专门数据类型 11.1 日期和时间 Python内建的datetime模块提供了datetime、date和time类型。datetime类型结合了date和time，是最常使用的： from datetime import datetime, date, time dt = datetime(2011, 10, 29, 20, 30, 21) dt.day ## 29 dt.date() ## datetime.date(2011, 10, 29) dt.time() ## datetime.time(20, 30, 21) strftime方法可以将datetime格式化为字符串： dt.strftime(&#39;%m/%d/%Y %H:%M&#39;) ## &#39;10/29/2011 20:30&#39; 类型 说明 %Y 四位数字的年 %y 两位数字的年 %m 两位数字的月[01，12] %d 两位数字的天[01，31] %H 小时（24小时制）[00，23] %l 小时（12小时制）[01，12] %M 两位数字的分[00，59] %5 秒[0，61]（60、61表示闰秒） %w 整数的周几[0（周日），6] %U 第几周[00，53]；周日当作一周的开始，第一个周日前面的天数作为”week 0” %W 第几周[00，53]；周一当作一周的开始，第一个周一前面的天数作为”week 0” %z UTC时区偏移量为+HHMM或-HHMM；不知道时区则为空 %F 表示%Y-%m-%d（即2012-4-18） %D 表示%m/%d/%y（即04/18/12） "],["title.html", "Chapter 12 Title 12.1 One", " Chapter 12 Title 12.1 One "],["applied-skills.html", "Chapter 13 实用技能 13.1 爬虫 13.2 中文分词", " Chapter 13 实用技能 13.0.1 文件和操作系统 13.0.1.1 文件的读写和关闭 f=open(&#39;somefile.txt&#39;) f.readline()#表示读文件的一行 f.readlines()#表示把文件从头到尾都读出来，并保存为一个列表 #使用文件应该牢记关闭 f.close() #更推荐下面这种方法，因为它会自动帮你关闭文件 with open(r&#39;somefile.txt&#39;) as f: f.readlines() #写入 f.write()#表示把字符串写入 f.writelines()#表示把一个列表写入 13.0.1.2 os模块 os模块提供了一种方便的使用操作系统函数的方法。 import os #假设在当前的目录下有一个abc.txt #重命名文件 os.rename(&#39;abc.txt&#39;,&#39;a123.txt&#39;) #删除文件 if os.path.exists(&#39;a123.txt&#39;): os.remove(&#39;a123.txt&#39;) #文件路径的处理 #假设有一个文件路径：path=&#39;/users/Python/Data/info.txt&#39; print(os.path.dirname(path)) #分割文件名 print(os.path.basename(path)) #分割文件的后缀 print(os.path.split(path)) #(&#39;/users/Python/Data&#39;, &#39;info.txt&#39;) #创建目录 os.mkdir(&#39;test01&#39;)#在当前目录下创建一个test01目录 os.mkdir(&#39;test02&#39;)#在当前目录下创建一个test02目录 #最后先判断目录是否存在 if not os.path.exists(&#39;test01&#39;): os.mkdir(&#39;test01&#39;) #列出当前目录下的所有文件和文件夹 print os.listdir(&#39;.&#39;) print list(os.walk(&#39;.&#39;)) #返回当前的目录 print os.getcwd() #删除目录，目录不为空时会报错 os.rmdir(&#39;test02&#39;) #shutil模块可以删除非空目录 shutil.rmtree(&#39;test02&#39;) #判断是否为文件 print os.path.isfile(&#39;test01&#39;) #判断是否为目录 print os.path.isdir(&#39;test01&#39;) #判断文件或者目录是否存在 print os.path.exists(&#39;demo_file.py&#39;) 标准库中的os模块里提供了system()函数，可以执行操作系统命令。比如在windows中，系统命令 start D:\\a.txt 就是启动程序自动打开D盘根目录中的 a.txt 文件。所以在Python程序中执行 os.system('start D:/a.txt') 就可以自动打开记事本显示该文件。 13.1 爬虫 Selenium 13.2 中文分词 pkuseg "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
