[["index.html", "我的Python笔记 前言", " 我的Python笔记 Xiaojun Sun 2021-11-30 前言 这一本写给自己看的Python学习笔记，不是一本正式的书。刚好看了 Xie (2016) ，在RStudio中可以很方便地编写gitbook，发现gitbook很适合组织知识和想法，比传统的blog更便于书写和阅读，所以开始以这种形式编写Python学习笔记。希望可以坚持下去！ 本书在Visual Studio Code中使用RMarkdown编写1。由于我设置了快捷键，在VS Code中使用 ctrl + alt + r 就可以快捷地编译书籍，编辑的结果可以通过网址http://127.0.0.1:4321进行预览。 References "],["build-env.html", "Chapter 1 搭建Python运行环境 1.1 安装Anaconda 1.2 环境管理 1.3 包的管理 1.4 Jupyter Notebook 1.5 IPython简介 1.6 PyCharm 1.7 运行Python程序", " Chapter 1 搭建Python运行环境 1.1 安装Anaconda 推荐使用Anaconda安装Python运行环境，在国内推荐清华大学开源软件镜像站进行下载。安装时注意Anaconda的安装路径不要出现空格。Anaconda安装成功之后，我们需要修改其包管理镜像为国内源。打开Anaconda Prompt，输入： conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ conda config --set show_channel_urls yes 1.2 环境管理 Anaconda自带的conda是包和环境的管理工具，适用于Python，R，Ruby等语言；pip则是Python自带的Python包管理器。一般推荐使用conda进行包和环境的管理。在Anaconda中Python的不同版本可以共存，使用conda可以创建当前环境（base）以外的新环境，如： conda create -n py27 python=2.7 #创建一个名字为py27，Python版本为2.7的新环境。Anaconda会自动下载安装相关的软件和包。 激活、退出和删除环境： activate py27 #激活环境 deactivate #退出环境 conda remove --name py27 --all #删除环境 conda env list #列出所有的环境。 1.3 包的管理 Anaconda中包的管理主要通过conda进行，以下命令均在Anaconda Prompt中执行。参阅官方文档。 1.3.1 搜索包 conda search scipy conda search --override-channels --channel defaults scipy #在Anaconda.org搜索 1.3.2 安装包 conda install -n myenv mypackage #在指定环境中安装包 conda install mypackage #在当前环境中安装包 conda install scipy=0.15.0 #安装指定版本的scipy包 conda install scipy curl #同时安装多个包 conda list #列出已安装的包 当然也可以在 Anaconda Prompt 中安装不在Anaconda上的包，但需要确保已在Anaconda中安装了pip包。如果没有安装可以通过conda install pip来安装。接着用pip安装需要的包即可： pip install mypackage #用pip安装包 1.3.3 更新包 conda update mypackage #更新包 conda update python #更新python conda update conda #更新conda conda update anaconda #Update Anaconda metapackage(所有的包) 1.3.4 卸载包 conda remove mypackage #卸载包 1.4 Jupyter Notebook Jupyter Notebook是基于网页的用于交互计算的应用程序。Jupyter Notebook可以在网页中直接编写代码和运行代码，代码的运行结果也会直接在代码块下显示。Jupyter可以支持多种语言，它的名字就是三种编程语言的组合：JUlia, PYThon, R。在Jupyter Notebook中使用Python时，其实使用的是IPython内核，所以很多IPython的功能都能在里面使用。 使用Jupyter Notebook之前，建议先更改Jupyter Notebook 打开的目录。右键点击Jupyter Notebook图标选择属性，将目标栏位从...-notebook-script.py %USERPROFILE%修改为...-notebook-script.py D:\\\\MyPython\\\\Dir %USERPROFILE%。其中D:\\\\MyPython\\\\Dir就是你希望打开的目录。 1.4.1 Jupyter Notebook常用技巧 支持同一代码块输出多个语句的执行结果： from IPython.core.interactiveshell import InteractiveShell InteractiveShell.ast_node_interactivity = &quot;all&quot; 使用Matplotlib作图时，需要在代码块第一行加入%matplotlib inline。 Jupyter Notebook中支持执行Shell命令，需要以!开头，比如： !ls *.ipynb !pip install numpy !dir 可以使用Jupyter Notebook制作幻灯片，需要使用RISE插件。 1.5 IPython简介 IPython是一个Python的交互式shell，比原生的python shell好用得多，提供了更为强大的编辑和交互功能，内置了许多很有用的功能和函数。注意：这些命令都只能在IPython交互式命令行工具中使用，不能在Python代码中使用。 1.5.1 帮助 可以搜索官方的最详细的帮助文档，可以点击Spyder工具栏中的HELP查看帮助文档，可以使用help函数查询帮助，比如help(abs) 。 1.5.2 Tab补全 Tab补全功能可以搜索已输入变量（对象、函数等等）的命名空间，可以补全任何对象的方法和属性，可以补全文件路径，可以补全函数的关键词参数（包括等于号=） 。 1.5.3 自省 在变量前后使用问号?，可以显示对象的信息： print? # 或者 ?print def add_numbers(a, b): &quot;&quot;&quot; Add two numbers together Returns ------- the_sum : type of arguments &quot;&quot;&quot; return a + b 使用?符号就可以显示函数的文档字符串： add_numbers? 使用??会显示函数的源码： add_numbers?? 使用?还可以搜索IPython的命名空间。字符与通配符结合可以匹配所有的名字。 import numpy as np np.*load*? 1.5.4 中断运行的代码 代码运行时按Ctrl-C，无论是%run或长时间运行命令，都会导致KeyboardInterrupt。这会导致几乎所有Python程序立即停止。 1.5.5 魔术命令 IPython提供了许多方便易用的魔术命令。魔术命令都带有百分号前缀。详细介绍可参考官方文档。常用的魔术命令有： 魔术命令 说明 %cd Change the current working directory. %dirs Return the current directory stack. %pwd Return the current working directory path. %load Load code into the current frontend. %run Run the named file inside IPython as a program. %conda Run the conda package manager within the current kernel. %time Time execution of a Python statement or expression. %timeit Time execution of a Python statement or expression %who Print all interactive variables, with some minimal formatting. %who_ls Return a sorted list of all interactive variables. %reset Resets the namespace by removing all names defined by the user. 1.6 PyCharm 集成化开发环境（IDE）将代码编辑、调试、运行、发布、环境配置、团队协作等各种功能集成在一个软件中，并且提供多种智能辅助开发手段，可以明显提高开发效率。PyCharm是JetBrains公司专门针对Python语言推出的集成开发环境，分为专业版（Professional）和社区版（Community），后者免费且功能足够一般开发学习使用。 PyCharm以“项目”形式组织Python源代码文件，应当先创建项目、再在其中新建Python文件。关于项目的基本理解要点如下： 开发一个软件往往需要编写大量代码，一般做法是将这些代码分散保存到多个Python程序文件中，再通过相互调用的方式协同运行，以便于代码阅读和修改； 这些属于同一软件的多个程序文件就被视作一个“项目”，一般保存在同一个文件夹中（可以在内部继续创建子文件夹）； 所以在PyCharm中，一个项目对应一个文件夹，里面可以新建多个Python文件。 PyCharm允许为每个项目分别指定不同的Python解释器（以及第三方模块库），具体可以在菜单 File -&gt; Settings -&gt; Project XXX -&gt; Project Interpreter 中添加和选择。事实上PyCharm相当于为每个项目都构建了一个“虚拟运行环境”，里面包含项目需要的所有工具和资源。 可以在PyCharm的菜单 File -&gt; Settings 的 Appearance 和 Editor 中设置界面配色、字体等外观选项。同时在Editor选项的Code Style -&gt; Python 中可以指定TAB缩进行为。建议不勾选 “Tab Character” ，这样每次按下TAB键插入缩进时，Python会自动生成若干空格实现缩进，从而避免使用 “TAB” 字符、防止不同系统下对Python解读混乱。 在PyCharm最左边找到“Structure”选项卡，点击后可以在小窗内显示Python程序的所有变量、函数等名称，便于快速定位。需要了解函数、变量等名称的详细含义时，可以按住CTRL键并将鼠标移动到该名称上。在PyCharm最下方可以找到Python交互式运行窗口和操作系统命令符窗口，以及运行和调试程序时的显示窗口等。调试程序时可以单击代码左侧灰色区域设置断点、使用F8（Step Over）和F7（Step Into）单步调试，同时在屏幕下方看到变量监视窗口。 可以在Code、Edit等菜单中找到 Indent/Unindent（增加/减少缩进）、Comment（添加/删除注释符号）、Surround（用if等结构包含代码）等快速编辑选项。 1.7 运行Python程序 在交互式环境中输入代码按下回车就可以执行，或者将python代码保存在.py文件中，在IPython中执行%run命令，或者在IDE中编写代码后点击RUN按钮。 注释是代码的重要组成部分，合理使用注释可以增强程序的可读性和可维护性。 &quot;&quot;&quot; 第一个Python程序 Version: 0.1 Author: XJ &quot;&quot;&quot; ## &#39;\\n第一个Python程序\\n\\nVersion: 0.1\\nAuthor: XJ\\n&#39; print(&quot;Hello, world!&quot;) # print(&quot;你好, 世界！&quot;) ## Hello, world! "],["control-flow.html", "Chapter 2 程序控制流程 2.1 if语句 2.2 while循环 2.3 for循环 2.4 continue 2.5 pass 2.6 三元表达式", " Chapter 2 程序控制流程 2.1 if语句 Python中if语句的一般形式如下所示： if condition_1: statement_block_1 elif condition_2: statement_block_2 else: statement_block_3 注意： 每个条件后面要使用冒号 :，表示接下来是满足条件后要执行的语句块。 使用缩进来划分语句块，相同缩进数的语句在一起组成一个语句块(block)。Python语言依靠冒号与缩进来表示“从属关系”。 在Python中没有switch – case语句。 2.2 while循环 从 while 后面的冒号开始，下面相对while存在缩进的连续代码均属于“循环体”，将会被重复执行。而从第一个不相对while缩进的语句开始，后面的代码都不再属于这个while的循环体；对于这些语句，只有当while循环彻底结束后才会被执行到。 while 循环在每执行一次循环体后，都会重新检查循环条件。如果循环条件仍然成立则再次执行循环体，否则结束循环。因此假如循环体中的代码不可能改变循环条件的判断结果，那么该循环将永远执行下去，成为“死循环”。构造死循环正规的方式是 while True 。 x = 256; total = 0 while x &gt; 0: if total &gt; 500: break total += x x = x//2 total ## 504 break语句可以跳出当前循环。在多重循环中，一个break语句只能跳出它所在的那一层循环，并不会一次跳出所有循环。continue语句则是直接进入下一次循环、跳过循环体后面的剩余代码。 2.3 for循环 for循环是在一个集合（列表或元组）中进行迭代。循环语句可能带有一个 else 子句；它会在循环遍历完列表 (使用 for) 或是在条件变为假 (使用 while) 的时候被执行，但是不会在循环被 break 语句终止时被执行。 for n in range(4, 6): for w in range(2, n): if n % w == 0: print(n, &#39;=&#39;, w, &#39;*&#39;, n // w) break else: # loop fell through without finding a factor print(n, &#39;is a prime number&#39;) ## 4 = 2 * 2 ## 5 is a prime number 其中，range函数返回一个迭代器，它产生一个均匀分布的整数序列，使用方法为：range(start, stop[, step])。比如： # 产生0到4的整数 for i in range(5): print(i) # 产生0到6的整偶数 ## 0 ## 1 ## 2 ## 3 ## 4 for i in range(0, 6, 2): print(i) ## 0 ## 2 ## 4 注意：如果在循环内需要修改序列中的值（比如重复某些选中的元素），推荐你先拷贝一份副本，切片操作使这件事非常简单： words = [&quot;Hello&quot;, &quot;my&quot;, &quot;darling&quot;] for w in words[:]: # Loop over a slice copy of the entire list. if len(w) &gt; 6: words.insert(0, w) 如果写成 for w in words:，这个示例就会创建无限长的列表。 2.4 continue continue 在语法上只会出现于for或 while 循环所嵌套的代码，它会继续执行最近的外层循环的下一个轮次。 for n in range(3, 6): if n % 2 == 0: print(&#39;Find a even number: &#39;, n) continue print(&#39;Find a odd number: &#39;, n) ## Find a odd number: 3 ## Find a even number: 4 ## Find a odd number: 5 2.5 pass pass是空语句，是为了保持程序结构的完整性，它不做任何事情，一般用做占位语句。 if x &lt; 0: print(&#39;negative!&#39;) elif x == 0: pass else: print(&#39;positive!&#39;) 2.6 三元表达式 Python中的三元表达式可以将if-else语句放到一行里。语法为： value = true-expr if condition else false-expr 举例： cond = True x = 100 if cond else 0 x ## 100 "],["built-in-type.html", "Chapter 3 内置数据类型（一） 3.1 None 3.2 字符串 3.3 数字 3.4 布尔值 3.5 bytes 3.6 Python运算符", " Chapter 3 内置数据类型（一） Python的内置数据类型包括： 数据类型 Python内置数据类型 文本类型 str 数值类型 int, float, complex 序列类型 list, tuple, range 映射类型 dict 集合类型 set, frozenset 布尔类型 bool 二进制类型 bytes, bytearray, memoryview 本章主要学习标量类型： 类型 说明 None Python的空值（只存在一个None对象的实例） str 字符串类型，存有Unicode（UTF-8编码）字符串 bytes 原生ASCII字节（或Unicode编码为字节） float 双精度（64位）浮点数（注意没有double类型） bool True或False值 int 任意精度整数 3.1 None None是Python的空值类型。如 果一个函数没有明确的返回值，就会默认返回None。N one也常常作为函数的默认参数。None不仅是一个保留字，还是唯一的NoneType的实例： type(None) ## &lt;class &#39;NoneType&#39;&gt; 3.2 字符串 你可以用单引号或双引号来表示字符串。反 斜杠 \\可以用来转义，被用来表示特殊字符 。 print(&#39;&quot;Yes,&quot; they said.&#39;) ## &quot;Yes,&quot; they said. print(&quot;\\&quot;Yes,\\&quot; they said.&quot;) ## &quot;Yes,&quot; they said. print(&#39;&quot;Isn\\&#39;t,&quot; they said.&#39;) ## &quot;Isn&#39;t,&quot; they said. 如果字符串中包含许多反斜杠，但没有特殊字符，这样做就很麻烦。幸好，可以在字符串前面加一个r，表明\\字符就是它自身，r的含义是原始字符串raw： s = r&#39;this\\has\\no\\special\\characters&#39; print(s) ## this\\has\\no\\special\\characters 字符串字面值可以跨行连续输入。一 种方式是用三重引号：\"\"\"...\"\"\" 或 '''...'''。字 符串行尾会自动加上回车换行，如果不需要回车换行，在行尾添加一个 \\ 即可。如下例： print(&quot;&quot;&quot;Line 1 Line 2 Line 3 &quot;&quot;&quot;) ## Line 1 ## Line 2 ## Line 3 字符串可以用 + 进行连接（粘到一起），也可以用 * 进行重复： 3 * &#39;un&#39; + &#39;ium&#39; ## &#39;unununium&#39; 相邻的两个或多个字符串字面值（引号引起来的字符）将会自动连接到一起。只 能对两个字面值这样操作，变量或表达式不行。如果你想连接变量，或者连接变量和字面值，可以用 + 号。 &#39;Py&#39; &#39;thon&#39; ## &#39;Python&#39; pre = &#39;py&#39; pre + &#39;thon&#39; ## &#39;python&#39; 拆分长字符串时，这个功能特别实用： text = (&#39;Put several strings within parentheses &#39; &#39;to have them joined together.&#39;) text ## &#39;Put several strings within parentheses to have them joined together.&#39; 字符串是可以被索引（下标访问）的，第一个字符索引是0。单个字符并没有特殊的类型，只是一个长度为一的字符串： word = &#39;Python&#39; word[0] #&#39;P&#39; ## &#39;P&#39; word[-1] #&#39;n&#39; ## &#39;n&#39; 除了索引，字符串还支持切片。索 引可以得到单个字符，而 切片可以获取子字符串。注意切片的开始总是被包括在结果中，而结束不被包括。这 使得 s[:i] + s[i:] 总是等于 s。 word[:2] #&#39;Py&#39; ## &#39;Py&#39; Python 中的字符串不能被修改，它们是不可变类型 （immutable ）。因此，向字符串的某个索引位置赋值会产生错误。 在Python 3中推荐使用f-Strings 进行字符串格式化。f -strings 是指以 f 或 F 开头的字符串，其中以 {} 包含的表达式会进行值替换。 name = &#39;hoxis&#39; age = 18 f&quot;hi, {name}, are you {age}&quot; ## &#39;hi, hoxis, are you 18&#39; 因为 f-strings 是在运行时计算的，那么这就意味着你可以在其中放置任意合法的 Python 表达式，比如： f&quot;{ 2 * 3 + 1}&quot; ## &#39;7&#39; import math print(f&#39;The value of pi is approximately {math.pi:.3f}.&#39;) ## The value of pi is approximately 3.142. name = &quot;Fred&quot; f&quot;He said his name is {name!r}.&quot; ## &quot;He said his name is &#39;Fred&#39;.&quot; width = 10 precision = 4 value = 12.34567 f&quot;result: {value:{width}.{precision}}&quot; ## &#39;result: 12.35&#39; 3.2.1 字符串格式化语法 字符串格式化语法如下: format_spec ::= [[fill]align][sign][#][0][width][grouping_option][.precision][type] fill ::= &lt;any character&gt; align ::= &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;=&quot; | &quot;^&quot; sign ::= &quot;+&quot; | &quot;-&quot; | &quot; &quot; width ::= digit+ grouping_option ::= &quot;_&quot; | &quot;,&quot; precision ::= digit+ type ::= &quot;b&quot; | &quot;c&quot; | &quot;d&quot; | &quot;e&quot; | &quot;E&quot; | &quot;f&quot; | &quot;F&quot; | &quot;g&quot; | &quot;G&quot; | &quot;n&quot; | &quot;o&quot; | &quot;s&quot; | &quot;x&quot; | &quot;X&quot; | &quot;%&quot; &#39;{}, {}, {}&#39;.format(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) ## &#39;a, b, c&#39; &#39;{2}, {1}, {0}&#39;.format(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) ## &#39;c, b, a&#39; &#39;{:&gt;30}&#39;.format(&#39;right aligned&#39;) ## &#39; right aligned&#39; &#39;{:*^30}&#39;.format(&#39;centered&#39;) # use &#39;*&#39; as a fill char ## &#39;***********centered***********&#39; import datetime d = datetime.datetime(2010, 7, 4, 12, 15, 58) &#39;{:%Y-%m-%d %H:%M:%S}&#39;.format(d) ## &#39;2010-07-04 12:15:58&#39; 3.3 数字 Python的主要数值类型是int和float。 3**3 ## 27 (30 - 2 * 3) / 5 ## 4.8 在交互模式下，上一次打印出来的表达式被赋值给变量 _： 2 + _ #6.8 3.3.1 浮点数 浮点数是一种类似科学计数法的数字表示方式，可以存放小数、整数等各种形式数字，Python中浮点数采用8个字节（64位二进制）空间。 因为十进制中的有限小数，在转换为二进制表示之后变成了无限长度小数，计算机不得不对它进行截断，从而导致计算误差。 可以使用内置函数round(原始数值, 保留小数位数) 实现四舍五入。Python3 中使用“银行家舍入法”，即“尾数为5时，看前一位数，奇进偶不进”。由于二进制转换误差的存在，类似 2.675 的数字在计算机中实质上相当于 2.6749999… ，所以使用 round 四舍五入的结果往往不同于预期。因此在精度需求较高的场合要慎用round。 round(1.345, 2) ## 1.34 round(1.335, 2) ## 1.33 标准模块 decimal 中的 Decimal 对象可以根据给定的参数（字符串形式）创建十进制数字对象，并完全基于十进制规则计算，从而避免二进制舍入误差。但是假如使用数字作为 Decimal 的参数，它就会先被 python 转换为二进制数字再交给Decimal，仍然可能引入精度误差。Decimal 类型的数字不能与普通小数直接运算；含有 Decimal 型数字的计算式，计算结果也是 Decimal 类型，可以使用 float() 等转换为普通数字。 from decimal import Decimal Decimal(0.1)+Decimal(0.2) ## Decimal(&#39;0.3000000000000000166533453694&#39;) Decimal(&#39;0.1&#39;)+Decimal(&#39;0.2&#39;) ## Decimal(&#39;0.3&#39;) Decimal(2).sqrt() ## Decimal(&#39;1.414213562373095048801688724&#39;) Decimal 数字的表示是完全精确的。 相比之下，1.1 和 2.2 这样的数字在二进制浮点中没有精确的表示。 最终用户通常不希望 1.1 + 2.2 如二进制浮点数表示那样被显示为 3.3000000000000003。精确性会延续到算术类操作中。 对于 decimal 浮点数，0.1 + 0.1 + 0.1 - 0.3 会精确地等于零。 而对于二进制浮点数，结果则为 5.5511151231257827e-017 。 虽然接近于零，但其中的误差将妨碍可靠的相等性检验，并且误差还会不断累积。 因此，decimal 更适合具有严格相等不变性要求的会计类应用。 可以将小数改为整数进行加、减、乘等运算，以利用Python长整型无溢出的特点，快速得到精确结果。但是如果需要在结果中添加小数点，建议先将其转换为字符串再使用切片操作，而不是直接除以 \\(10^n\\) ，因为整数除法还是会产生浮点数，导致截断误差。 3.3.2 随机数 random 3.4 布尔值 Python中的布尔值有两个，True和False。布尔类型（逻辑类型）其实是整数类型（int）的子类，True和False在算术式中会被自动视作1和0 。 任何类型的数据或对象都可以被视作True或False。具体对应则为：0和“空”（空字符串、空列表、空对None、空元组、空集合 …… ）含义的值，会在 if 等需要逻辑值的场合中被自动认为 False，其他则认为是 True。（实际情况可能比这个描述更复杂一些，因为在设计编写一个类时，程序员可以自己指定该类对象在什么场合下被视作 True 或 False）。 内置函数 bool() 可以根据前述规则得到某个数据的对应逻辑值。需要注意的是：根据前述规则，bool(“False”) 的结果是True而非False。 bool(&quot;False&quot;) ## True 3.5 bytes bytes是一种比特流，它的存在形式是01010001110这种。我们无论是在写代码，还是阅读文章的过程中，肯定不会有人直接阅读这种比特流，它必须有一个编码方式，使得它变成有意义的比特流，而不是一堆晦涩难懂的01组合。 bytes 只负责以字节序列的形式（二进制形式）来存储数据，至于这些数据到底表示什么内容（字符串、数字、图片、音频等），完全由程序的解析方式决定。如果采用合适的字符编码方式（字符集），字节串可以恢复成字符串；反之亦然，字符串也可以转换成字节串。bytes 类型的数据非常适合在互联网上传输，可以用于网络通信编程；bytes 也可以用来存储图片、音频、视频等二进制格式的文件。 字符串和 bytes 存在着千丝万缕的联系，我们可以通过字符串来创建 bytes 对象，或者说将字符串转换成 bytes 对象。字符串类str有一个encode()方法，它是从字符串向比特流的编码过程。而bytes类型恰好有个decode()方法，它是从比特流向字符串解码的过程。 字节串（bytes）和字符串（string）的对比： 在将字符串存入磁盘和从磁盘读取字符串的过程中，Python自动地帮你完成了编码和解码的工作，你不需要关心它的过程。 使用bytes类型，实质上是告诉Python，不需要它帮你自动地完成编码和解码的工作，而是用户自己手动进行，并指定编码格式。 a = &quot;中文&quot; b = bytes(a, encoding = &#39;UTF-8&#39;) type(b) ## &lt;class &#39;bytes&#39;&gt; str(b, encoding = &#39;UTF-8&#39;) ## &#39;中文&#39; a = &quot;中文&quot; b = a.encode(encoding = &#39;UTF-8&#39;) b.decode(encoding = &#39;UTF-8&#39;) ## &#39;中文&#39; 3.6 Python运算符 3.6.1 算术运算符 运算 说明 a+b a加b a-b a减b a*b a乘以b a/b a除以b a%b 取模 - 返回除法的余数 a//b 取整除 - 返回商的整数部分（向下取整） a**b a的b次幂 3.6.2 比较运算符 运算符 说明 a&amp;b a或b都为True，则为True；对于整数，取逐位AND a|b a或b有一个为True，则为True；对于整数，取逐位OR a^b 对于布尔，a或b有一个为True，则为True，二者都为True，为False；对于整数，取逐位EXCLUSIVE-OR a==b a等于b，则为True a!=b a不等于b，则为True a&lt;b，a&lt;=b a小于（或小于等于）b，则为True a&gt;b，a&gt;=b a大于（或大于等于）b，则为True a is b a和b引用同一个Python对象，则为True a is not b a和b引用不同的Python对象，则为True 可以把比较运算符串在一起: a&gt;b&gt;c&gt;d： 5&gt;2&gt;3&gt;1 ## False 3.6.3 逻辑运算符 逻辑运算符包括 and 、or 和 not。一个判断子句中可以使用多个关系表达式表达复杂条件，只要使用逻辑运算符 and、or、not 等将其组合在一起即可。优先级排序：not &gt; and &gt; or。可以使用圆括号修改优先级。 运算符 描述 and 两端的逻辑值全部为 True， 则计算结果为 True；任何一端为False，则计算结果为 False or 两端的逻辑值只要有一个为 True，计算结果就是 True；如果两端都为 False，则结果为 False not 结果为右侧逻辑值的取反值 a = 5; b = 10 (a&gt;b) and (b&lt;12) or (a&gt;1) and not a ## False 3.6.4 成员运算符 运算符 描述 in 如果在指定的序列中找到值返回 True，否则返回 False。 not in 如果在指定的序列中没有找到值返回 True，否则返回 False。 3.6.5 身份运算符 运算符 描述 实列 is 判断两个标识符是不是引用自一个对象 x is y, 等同于 id(x) == id(y) is not 判断两个标识符是不是引用自不同对象 x is not y, 等同于 id(x) != id(y) is 与 == 区别：is 用于判断两个变量引用对象是否为同一个(同一块内存空间)2， == 用于判断引用变量的值是否相等。 a = 1; b = 1 print(f&quot;a的内存地址是{id(a)}，b的内存地址是{id(b)}&quot;) ## a的内存地址是631728432，b的内存地址是631728432 a is b ## True id() 函数用于获取对象内存地址。↩︎ "],["built-in-type2.html", "Chapter 4 内置数据类型（二） 4.1 列表list 4.2 元组tuple 4.3 字典dict 4.4 集合set 4.5 不可变对象 4.6 序列函数 4.7 列表推导式", " Chapter 4 内置数据类型（二） 4.1 列表list list是Python内置的一种数据类型，list是一个可变的有序表，可以随时添加和删除其中的元素。比如，列出班里所有同学的名字，就可以用一个list表示： classmates = [&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;] 用len()函数可以计算list中元素的个数。用索引可以访问list中每一个位置的元素，记得索引是从0开始的，最后一个元素的索引是len(classmates) - 1 ，还可以用-1做索引直接获取最后一个元素；用-2做索引可以直接获取倒数第二个元素。 # 可以往list中追加元素到末尾 classmates.append(&#39;Adam&#39;) #用extend方法可以追加多个元素 classmates.extend(&#39;Jony&#39;,&#39;Tom&#39;) # 也可以把元素插入到指定的位置 classmates.insert(1, &#39;Jack&#39;) # 可以用pop()方法删除list中的元素 classmates.pop(2) #可以直接赋值给对应的索引位置 classmates[1] = &#39;Sarah&#39; # 可以把元素插入到指定的位置 classmates.insert(1, &#39;Jack&#39;) #list里面的元素的数据类型也可以不同 L = [&#39;Apple&#39;, 123, True] #list的元素也可以是另一个list s = [&#39;python&#39;, &#39;java&#39;, [&#39;asp&#39;, &#39;php&#39;], &#39;scheme&#39;] #用in可以检查列表是否包含某个值 &#39;java&#39; in s #TRUE #可以用加号将两个列表串联起来，但没有extend好 [4, None, &#39;foo&#39;] + [7, 8, (2, 3)] #[4, None, &#39;foo&#39;, 7, 8, (2, 3)] #排序方法 s.sort() s.sort(key=len) #二级排序key #切片 s[1:3]; s[-2:] 4.2 元组tuple 另一种有序列表叫元组：tuple。t uple和list非常类似，但是tuple一旦初始化就不能修改。 classmates = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;) 现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。 只有1个元素的tuple定义时必须加一个逗号,，来消除歧义 t = (1,) t ## (1,) 可以用加号运算符将元组串联起来： (4, None, &#39;foo&#39;) + (6, 0) + (&#39;bar&#39;,) ## (4, None, &#39;foo&#39;, 6, 0, &#39;bar&#39;) 拆分元组： tup = (4, 5, 6) a, b, c = tup a, b = 1, 2 b, a = a, b values = 1, 2, 3, 4, 5 a, b, *rest = values 4.3 字典dict Python内置了字典（dict），dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。 d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85} d[&#39;Michael&#39;] ## 95 给定一个名字，比如'Michael'，dict在内部就可以直接计算出Michael对应的存放成绩的”页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。 #把数据放入dict，除了初始化时指定外，还可以通过key放入 d[&#39;Adam&#39;] = 67 #删除一个key d.pop(&#39;Bob&#39;) #dict可以接受2元元组的列表 ## 75 mapping = dict(zip(range(5), reversed(range(5)))) dict内部存放的顺序和key放入的顺序是没有关系的。和 list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict是用空间来换取时间的一种方法。 dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。 这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这 个通过key计算位置的算法称为哈希算法（Hash）。要 保证hash的正确性，作为key的对象就不能变。在 Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而 list是可变的，就不能作为key。 4.4 集合set set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以在set中没有重复的key。 要创建一个set，可以提供一个list作为输入集合，或者使用{...}： set([1, 2, 3]) ## {1, 2, 3} {1,2,3} ## {1, 2, 3} 注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这三个元素，显示的顺序也不表示set是有序的。 重复元素在set中自动被过滤： set([1, 1, 2, 2, 3, 3]) ## {1, 2, 3} s = {1, 1, 2, 2, 3, 3} # 可以添加元素到set中 s.add(4) # 可以删除元素 s.remove(4) set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作： s1 = set([1, 2, 3]) s2 = set([2, 3, 4]) s1 &amp; s2 ## {2, 3} s1 | s2 ## {1, 2, 3, 4} s1 - s2 ## {1} 4.5 不可变对象 Python中的大多数对象，比如列表、字典、NumPy数组、用户定义的类，都是可变的。这意味着这些对象或包含的值可以被修改： a_list = [&#39;foo&#39;, 2, [4, 5]] a_list[2] = (3, 4) 其它的，比如字符串和元组，是不可变的： a_tuple = (3, 5, (4, 5)) a_tuple[1] = &#39;four&#39; #TypeError 注意，可以修改一个对象并不意味就要修改它，这被称为副作用。 4.6 序列函数 4.6.1 enumerate函数 enumerate函数可以返回(i, value)元组序列 for i, v in enumerate(some_list): mapping[v] = i 4.6.2 sorted函数 sorted函数可以从任意序列的元素返回一个新的排好序的列表，sorted函数可以接受和sort方法相同的参数。 sorted([7, 1, 2, 6, 0, 3, 2]) ## [0, 1, 2, 2, 3, 6, 7] 4.6.3 zip函数 zip可以将多个列表、元组或其它序列成对组合成一个元组列表： seq1 = [&#39;foo&#39;, &#39;bar&#39;, &#39;baz&#39;] seq2 = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;] zipped = zip(seq1, seq2) zipped ## &lt;zip object at 0x0000000029A0F6C0&gt; zip可以处理任意多的序列，元素的个数取决于最短的序列。zip的常见用法之一是同时迭代多个序列，可能结合enumerate使用 。 zip也可以当作把行的列表转换为列的列表（很神奇）。 pitchers = [(&#39;Nolan&#39;, &#39;Ryan&#39;), (&#39;Roger&#39;, &#39;Clemens&#39;), (&#39;Schilling&#39;, &#39;Curt&#39;)] first_names, last_names = zip(*pitchers) first_names;last_names ## (&#39;Nolan&#39;, &#39;Roger&#39;, &#39;Schilling&#39;) ## (&#39;Ryan&#39;, &#39;Clemens&#39;, &#39;Curt&#39;) 4.7 列表推导式 列表推导式(list comprehensions)是Python最受喜爱的特性之一。它允许用户方便的从一个集合过滤元素，形成列表，在传递参数的过程中还可以修改元素。 [expr for val in collection if condition] dict_comp = {key-expr : value-expr for value in collection if condition} #字典 set_comp = {expr for value in collection if condition} #集合 举例如下： print([i**2 for i in range(20) if i % 3 is 0]) ## [0, 9, 36, 81, 144, 225, 324] mcase = {&#39;a&#39;: 10, &#39;b&#39;: 34} print({v: k for k, v in mcase.items()}) ## {10: &#39;a&#39;, 34: &#39;b&#39;} print({x**2 for x in [1, 1, 2]}) ## {1, 4} 嵌套列表推导式，包含两层for循环： some_tuples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)] flattened = [x for tup in some_tuples for x in tup if x&gt;5] flattened ## [6, 7, 8, 9] "],["function.html", "Chapter 5 Python函数", " Chapter 5 Python函数 函数是Python中最主要也是最重要的代码组织和复用手段。作为最重要的原则，如果你要重复使用相同或非常类似的代码，就需要写一个函数。 函数使用def关键字声明，用return关键字返回值： def my_function(x, y, z=1.5): if z &gt; 1: return z * (x + y) else: return z / (x + y) 同时拥有多条return语句也是可以的。如果到达函数末尾时没有遇到任何一条return语句，则返回None。 函数可以有一些位置参数（positional）和一些关键字参数（keyword）。关键字参数通常用于指定默认值或可选参数。在上面的函数中，x和y是位置参数，而z则是关键字参数。也就是说，该函数可以下面这两种方式进行调用： my_function(5, 6, z=0.7) ## 0.06363636363636363 my_function(3.14, 7, 3.5) ## 35.49 my_function(10, 20) ## 45.0 函数参数的主要限制在于：关键字参数必须位于位置参数（如果有的话）之后。你可以任何顺序指定关键字参数。也就是说，你不用死记硬背函数参数的顺序，只要记得它们的名字就可以了。 注意：也可以用关键字传递位置参数，这种写法可以提高可读性。前面的例子，也可以写为： my_function(x=5, y=6, z=7) my_function(y=6, x=5, z=7) 重要警告：默认值只会执行一次。执行函数定义时，从左到右计算默认参数值。这意味着只在函数定义的时候该表达式求一次值，以后每次调用使用相同的“提前计算好的”值。这条规则在默认值为可变对象（列表、字典以及大多数类实例）时很重要。如果函数修改了该对象（例如，向列表添加一个元素），默认值将受影响被修改。比如，下面的函数会存储在后续调用中传递给它的参数： def f(a, L=[]): L.append(a) return L f(1) ## [1] f(2) ## [1, 2] 如果你不想要在后续调用之间共享默认值，你可以使用None作为默认值，并在函数体中明确测试它： def f(a, L=None): if L is None: L = [] L.append(a) return L 在函数调用中，关键字参数必须跟随在位置参数的后面。传递的所有关键字参数必须与函数接受的其中一个参数匹配，它们的顺序并不重要。不能对同一个参数多次赋值。 **name形式的形式参数3将接收一个字典，这个字典包含除形式参数之外的所有关键字参数；*name形式的形式参数接收一个元组，这个元组包含除形式参数之外的所有位置参数。(*name必须出现在**name之前） def myfun(kind, *arguments, **keywords): statements ...... 如果一个参数具有默认值，所有随后的参数直到“*” 也必须具有默认值。所以下面的函数定义语句会报错。 def funx(a, b = 2, c): print(a+b+c) 5.0.1 返回多个值 函数可以返回多个值。下面是一个简单的例子： def f(): a = 5 b = 6 c = 7 return a, b, c a, b, c = f() 在数据分析和其他科学计算应用中，你会发现自己常常这么干。该函数其实只返回了一个对象，也就是一个元组，最后该元组会被拆包到各个结果变量中。在上面的例子中，我们还可以这样写：return_value = f()。这里的return_value将会是一个含有3个返回值的三元元组。此外，还有一种非常具有吸引力的多值返回方式——返回字典： def f(): a = 5 b = 6 c = 7 return {&#39;a&#39; : a, &#39;b&#39; : b, &#39;c&#39; : c} 取决于工作内容，第二种方法可能很有用。 The term parameter (sometimes called formal parameter) is often used to refer to the variable as found in the function definition, while argument (sometimes called actual parameter) refers to the actual input supplied at function call.↩︎ "],["reg-expr.html", "Chapter 6 字符串与正则表达式 6.1 one 6.2 two", " Chapter 6 字符串与正则表达式 6.1 one 6.2 two "],["container.html", "Chapter 7 深入理解各种容器 7.1 迭代器", " Chapter 7 深入理解各种容器 7.1 迭代器 你可能注意到大多数容器对象都可以用 for 遍历： for element in [1, 2, 3]: print(element) for element in (1, 2, 3): print(element) for key in {&#39;one&#39;:1, &#39;two&#39;:2}: print(key) for char in &quot;123&quot;: print(char) for line in open(&quot;myfile.txt&quot;): print(line, end=&#39;&#39;) 这种访问风格清晰、 简洁又方便。迭代器的用法在 Python 中普遍而且统一。在后台，for语句调用容器对象的iter()方法。该函数返回一个定义了__next__()方法的迭代器对象，它一次访问容器中的一个元素。没有后续的元素时，__next__() 会引发StopIteration异常，告诉 for循环停止迭代。你可以使用内建的 next()来调用__next__()，例子如下： # -*- coding: utf-8 -*- s = &#39;abc&#39; it = iter(s) it ## &lt;str_iterator object at 0x0000000029EF7A90&gt; next(it),next(it),next(it) ## (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) "],["module.html", "Chapter 8 模块", " Chapter 8 模块 模块是一个包含Python定义和声明的文件。文件名就是模块名后跟文件后缀 .py 。在一个模块内部，模块名（作为一个字符串）可以通过全局变量 __name__ 的值获得。例如，使用在当前目录下创建一个名为 fibo.py 的文件， 文件中含有以下内容： # fibo.py def fib(n): a, b = 0, 1 while a &lt; n: print(a, end=&#39; &#39;) a, b = b, a+b print() def fib2(n): result = [] a, b = 0, 1 while a &lt; n: result.append(a) a, b = b, a+b return result 导入该模块： import fibo 模块名fibo被导入到当前符号表中，但是fibo中定义的函数名称不会直接导入当前工作表内。可以用模块名访问这些函数： fibo.fib(50) fibo.__name__ #&#39;fibo&#39; 如果你想经常使用某个函数，你可以把它赋值给一个本地名称: myfib = fibo.fib 模块可以包含可执行语句以及已定义的函数。这些语句通常用于初始化模块。只有在导入语句中第一次遇到模块名称时，才会执行。如果文件以脚本的方式执行，它们也会运行。 每个模块都有自己的私有符号表，它被定义在模块中所有函数当作全局符号表一样使用。 模块中可以导入其它模块。一般来说，习惯性地将所有 import 语句放在模块（或脚本）的开头，但这不是必须的。被导入的模块的名字存放在导入模块的全局符号表中。 另外有一种import语句的变种，可以从一个模块直接将名称导入到当前符号表中。例如： from fibo import fib, fib2 一般情况下不建议使用from fibo import *这种导入方式，因为它会引入一系列未知的名称到解释器中，这很可能覆盖你已经定义的一些东西。 使用as关键词，你可以给导入的名称重命名： from fibo import fib as fun1, fib2 as fun2 8.0.0.1 以脚本的方式执行模块 一个 Python 源码文件除了可以被直接运行外，还可以作为模块（也就是库）被导入。不管是导入还是直接运行，最顶层的代码都会被运行（Python 用缩进来区分代码层次）。 在命令行窗口中，可以使用python fibo.py &lt;arguments&gt;执行模块里的代码。在IPython中，可以使用%run fibo.py &lt;arguments&gt;执行模块里的代码，这同时会将模块中定义的函数导入当前符号表中。 __main__ 是顶层代码执行的作用域的名称。模块的 __name__ 在通过标准输入、脚本文件或是交互式命令读入的时候会等于 __main__。 模块可以通过检查自己的 __name__ 来得知是否运行在 main 作用域中，这使得模块可以在作为脚本或是通过 python -m 运行时条件性地执行一些代码，而在被 import 时不会执行。 实现方式是在模块中添加if __name__ == '__main__' 代码块： if __name__ == &quot;__main__&quot;: import sys fib(int(sys.argv[1])) 简单的理解就是： 如果模块是被直接运行的，则代码块被运行，如果模块是被导入的，则代码块不被运行。4 对软件包来说，通过加入 __main__.py 模块可以达到同样的效果，当使用 -m 运行模块时，其中的代码会被执行。 8.0.0.2 编译好的模块 为了加快加载模块的速度，Python在__pycache__目录下缓存每个模块编译好的版本，名字为module.version.pyc，其中version表示编译好的文件的格式；它一般包含Python的版本号。例如，在Python 3.3中，spam.py编译好的版本将缓存为 __pycache__/spam.cpython-33.pyc。这种命名约定允许由不同发布和不同版本的Python编译的模块同时存在。 Python会检查源文件和编译好的版本的修改日期，来查看它是否过期以及需要重新编译。这是完全自动化的过程。同时，编译后的模块是跨平台的，所以同一个库可以在不同架构的系统之间共享。 Python 在两种情况下不检查缓存。第一，它会始终重新编译而且不保存直接从命令行加载的模块。第二，如果没有源模块，它不会检查缓存。若要支持没有源文件（只有编译版）的发布，编译后的模块必须在源目录下，并且必须没有源模块。 8.0.0.3 标准模块 Python附带了一个标准模块库，有单独的Python库参考手册。有一些模块内置于解释器中；它们提供对不属于语言核心但仍然内置的操作的访问，以提高效率或提供对系统调用等操作系统原语的访问。这些模块的集合是一个配置选项，它也取决于底层平台。例如，winreg 模块只在Windows操作系统上提供。一个特别值得注意的模块 sys，它被内嵌到每一个Python解释器中。变量 sys.ps1 和 sys.ps2 定义了主提示符和辅助提示符使用的字符串: import sys sys.ps1 sys.ps2 # 注意：只有在交互式模式中，这两个变量才有定义 8.0.0.4 dir()函数 内置函数 dir() 用来找出模块中定义了哪些名称。它返回一个排好序的字符串列表： dir(fibo) # [&#39;__name__&#39;, &#39;fib&#39;, &#39;fib2&#39;] 如果不带参数， dir() 列出当前环境中已定义的名称。dir()不会列出内置的函数和变量的名称。 8.0.0.5 包 包是一种通过用“带点号的模块名”来构造 Python 模块命名空间的方法。 例如，模块名 A.B 表示 A 包中名为 B 的子模块。正如模块的使用使得不同模块的作者不必担心彼此的全局变量名称重名一样，使用加点的模块名可以使得 NumPy 或 Pillow 等多模块软件包的作者不必担心彼此的模块名称重名。 当使用 from package import item 时，item可以是包的子模块（或子包），也可以是包中定义的其他名称，如函数，类或变量。 import 语句首先测试是否在包中定义了item；如果没有，它假定它是一个模块并尝试加载它。如果找不到它，则引发 ImportError 异常。 相反，当使用 import item.subitem.subsubitem 这样的语法时，除了最后一项之外的每一项都必须是一个包；最后一项可以是模块或包，但不能是前一项中定义的类或函数或变量。 8.0.0.6 从包中导入 * 首先，from pkg import *是不建议的导入方法。如果要使用这种方法，一般应该在__init__.py中提供包的显式索引。 如果一个包的 __init__.py 代码定义了一个名为 __all__ 的列表，它会被视为在遇到 from package import * 时应该导入的模块名列表。如果包作者认为从他的包中导入 * 的操作没有必要被使用，也可以决定不支持此列表。 8.0.1 命名空间和作用域 命名空间（namespace）是 Python 最核心的内容。Python的名字实际上是一个字符串对象，它和所指向的目标对象一起在命名空间中构成一项 {name: object} 关联。所以命名空间是从名字到对象的一个映射(a mapping from name to objects) 。 大部分命名空间都是按Python中的字典来实现的。名字的作用仅仅是在某个时刻与名字空间中的某个对象进行关联。其本身不包含目标对象的任何信息，只有通过对象头部的类型指针才能获知其具体类型，进而查找其相关成员数据。正因为名字的弱类型特征，我们可以在运行期间随时将其关联到任何类型对象。 在程序执行期间，可能（其实是肯定）会有多个命名空间同时存在。不同命名空间的创建/销毁时间也不同。此外，两个不同命名空间中的两个相同名字的变量之间没有任何联系。 一个作用域(Scope)是一个命名空间可直接访问的 Python 程序的文本区域。这里的 “可直接访问” 意味着对名称的非限定引用会尝试在命名空间中查找名称。 Local(innermost):包含局部变量。比如一个函数/方法内部。 Enclosing: 包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，内层函数可能搜索外层函数的namespace，但该namespace对内层函数而言既非局部也非全局。 Global(next-to-last): 当前脚本的最外层。比如当前模块的全局变量。 Built-in(outtermost): Python __builtin__ 模块。包含了内建的变量/关键字等。 作用域的搜索顺序是：Local -&gt; Enclosing -&gt; Global -&gt; Built-in def scope_test(): def do_local(): spam = &quot;local spam&quot; def do_nonlocal(): nonlocal spam spam = &quot;nonlocal spam&quot; def do_global(): global spam spam = &quot;global spam&quot; spam = &quot;test spam&quot; do_local() print(&quot;After local assignment:&quot;, spam) do_nonlocal() print(&quot;After nonlocal assignment:&quot;, spam) do_global() print(&quot;After global assignment:&quot;, spam) scope_test() ## After local assignment: test spam ## After nonlocal assignment: nonlocal spam ## After global assignment: nonlocal spam print(&quot;In global scope:&quot;, spam) ## In global scope: global spam 可以看到，局部赋值不会改变 scope_test 对 spam 的绑定（enclosing）。 nonlocal 赋值会改变 scope_test 对 spam 的绑定，而 global 赋值会改变模块层级的绑定。 def outer(): a = 0 b = 1 def inner(): print(a) print(b) # b += 1 # A b = 4 # B inner() outer() # UnboundLocalError: local variable &#39;b&#39; referenced before assignment Python解释器执行到 inner() 中的 print b 时，发现有个变量 b，在当前作用域(local)中无法找到该变量。它继续尝试把整块代码解释完，b 是属于 inner() 作用域的，既然对变量 b 的赋值（声明）发生在 print 语句之后， print 语句执行时变量 b 是还未被声明的，于是抛出错误：变量在赋值前就被引用。在这个例子中，只有A语句没有B语句也会导致同样的结果。 因为b没有被声明为非本地变量(nonlocal)，在inner()的局部空间中b是只读的（尝试写入b的赋值语句只会在最内层作用域中创建一个新的局部变量，而同名的外部变量保持不变）。 for i in range(3): print(i) ## 0 ## 1 ## 2 print(&quot;i =&quot;, i) ## i = 2 for 后面跟着的变量(target list)在循环结束后是不会被删除的，但如果 for 循环的序列为空，这些变量是完全不会被赋值的。 参考资料：Python 中的 if __name__ == __main__ 该如何理解↩︎ "],["OOP.html", "Chapter 9 Python 面向对象 9.1 术语简介 9.2 创建类 9.3 类对象 9.4 实例对象 9.5 方法对象 9.6 类和实例变量 9.7 Python内置类属性 9.8 补充说明 9.9 类的继承 9.10 私有变量 9.11 元类", " Chapter 9 Python 面向对象 先有类型 (class)，再有对象(object)。Python 中的一切都是对象，包括类型。每个对象都有明确的类型。 9.1 术语简介 类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 类变量：类的所有实例共享的属性和方法。类变量定义在类中且在函数体之外。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 局部变量：定义在方法中的变量，只作用于当前实例的类。 实例变量：独属于每个实例的属性。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。 实例化：创建一个类的实例，类的具体对象。 方法：类中定义的函数。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 9.2 创建类 类(classes)定义的形式如下： class ClassName: &#39;类的帮助信息&#39; &lt;statement-1&gt; ... &lt;statement-N&gt; 类定义与函数定义 (def 语句) 一样必须被执行才会起作用。当进入类定义时，将创建一个新的命名空间，并将其用作局部作用域。因此，所有对局部变量的赋值都是在这个新命名空间之内。 9.3 类对象 类对象支持两种操作：属性引用和实例化。 类对象的属性引用使用 Python 中所有属性引用所使用的标准语法: obj.name。 有效的属性名称是类对象被创建时存在于类命名空间中的所有名称。 因此，如果类定义是这样的: class MyClass: &quot;&quot;&quot;A simple example class&quot;&quot;&quot; i = 12345 def f(self): return &#39;hello world&#39; 那么 MyClass.i 和 MyClass.f 就是有效的属性引用，将分别返回一个整数和一个函数对象。 类属性也可以被赋值，因此可以通过赋值来更改 MyClass.i 的值。 __doc__ 也是一个有效的属性，将返回所属类的文档字符串：“A simple example class”。 类的实例化使用函数表示法，可以假装类对象就是会返回一个新的类实例的函数。 举例来说：x = MyClass()，将创建MyClass类的新实例并将此对象分配给局部变量x。 如果一个类定义了 __init__() 方法，创建了这个类的实例时就会调用该方法，可以看成是类实例的初始化操作。 当然，__init__() 方法还可以有额外参数以实现更高灵活性。在这种情况下，提供给类实例化运算符的参数将被传递给 __init__()。 例如： class Complex: def __init__(self, realpart, imagpart): self.r = realpart self.i = imagpart x = Complex(3.0, -4.5) x.r, x.i ## (3.0, -4.5) 9.4 实例对象 实例对象(Instance Objects)支持的唯一操作是属性引用。有效的属性名称有两种：数据属性和方法。数据属性不需要声明；像局部变量一样，它们将在第一次被赋值时产生。另一类实例属性是方法，方法是从属于对象的函数。（在 Python中，方法这个术语并不是类实例所特有的，其他对象也可以有方法。） 9.5 方法对象 x.f 是一个方法对象，它可以被保存起来以后再调用。 x = MyClass() x.f() ## &#39;hello world&#39; xf = x.f xf() ## &#39;hello world&#39; MyClass.f() # TypeError: f() missing 1 required positional argument: &#39;self&#39; 可以看到， x.f()没有报错，但 MyClass.f() 报错了。所以 x.f 与 MyClass.f 并不是一回事，它们是一个方法对象，一个是函数对象。 方法的特殊之处就在于实例对象会作为函数的第一个参数被传入。 在我们的示例中，调用 x.f() 其实就相当于 MyClass.f(x)。总之，调用一个具有n个参数的实例方法就相当于调用n+1个参数的对应函数，增加的这个参数值就是方法所属的实例对象，位置在其他参数之前。 9.6 类和实例变量 一般来说，实例变量(instance variable)是唯一属于每个实例的数据，而类变量(class variable)则是类的所有实例共享的属性和方法： class Dog: kind = &#39;canine&#39; # class variable shared by all instances def __init__(self, name): self.name = name # instance variable unique to each instance d = Dog(&#39;Fido&#39;) e = Dog(&#39;Buddy&#39;) d.kind, e.kind # shared by all dogs ## (&#39;canine&#39;, &#39;canine&#39;) d.name # unique to d ## &#39;Fido&#39; e.name # unique to e ## &#39;Buddy&#39; 9.7 Python内置类属性 __dict__ : 类的属性（包含一个字典，由类的数据属性组成） __doc__ :类的文档字符串 __name__: 类名 __module__: 类定义所在的模块（类的全名是__main__.className，如果类位于一个导入模块mymod中，那么className.__module__ 等于 mymod） __bases__ : 类的所有父类构成元素（包含了一个由所有父类组成的元组） class Employee: &#39;base class&#39; empCount = 0 def __init__(self, name, salary): self.name = name self.salary = salary Employee.empCount += 1 def displayCount(self): print(&quot;Total Employee %d&quot; % Employee.empCount) def displayEmployee(self): print(&quot;Name : &quot;, self.name, &quot;, Salary: &quot;, self.salary) print(&quot;Employee.__doc__:&quot;, Employee.__doc__) ## Employee.__doc__: base class print(&quot;Employee.__name__:&quot;, Employee.__name__) ## Employee.__name__: Employee print(&quot;Employee.__module__:&quot;, Employee.__module__) ## Employee.__module__: __main__ print(&quot;Employee.__bases__:&quot;, Employee.__bases__) ## Employee.__bases__: (&lt;class &#39;object&#39;&gt;,) print(&quot;Employee.__dict__:&quot;, Employee.__dict__) ## Employee.__dict__: {&#39;__module__&#39;: &#39;__main__&#39;, &#39;__doc__&#39;: &#39;base class&#39;, &#39;empCount&#39;: 0, &#39;__init__&#39;: &lt;function Employee.__init__ at 0x0000000029A1B280&gt;, &#39;displayCount&#39;: &lt;function Employee.displayCount at 0x0000000029A1B310&gt;, &#39;displayEmployee&#39;: &lt;function Employee.displayEmployee at 0x0000000029A1B3A0&gt;, &#39;__dict__&#39;: &lt;attribute &#39;__dict__&#39; of &#39;Employee&#39; objects&gt;, &#39;__weakref__&#39;: &lt;attribute &#39;__weakref__&#39; of &#39;Employee&#39; objects&gt;} 9.8 补充说明 数据属性会覆盖同名的方法属性，这在大型程序中可能带来极难发现的 bug。为了避免意外的命名冲突，使用一些约定来减少冲突的几率是明智的。可能的约定包括：方法属性名称的首字母大写，数据属性名称的前缀使用一个唯一的小写的字符串（也许只是一个下划线），或者方法使用动词而数据属性使用名词。 类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称，按照惯例它的名称是 self。这仅仅是一个约定， self 对 Python 而言绝对没有任何特殊含义。但是如果不遵循这个约定，对其他的 Python 程序员而言你的代码可读性就会变差，而且有些类 查看器程序也可能是遵循此约定编写的。 class Test: def prt(self): print(self) print(self.__class__) t = Test() t.prt() ## &lt;__main__.Test object at 0x0000000029C21730&gt; ## &lt;class &#39;__main__.Test&#39;&gt; 从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.__class__ 则指向类。 类属性的任何函数对象都为那个类的实例定义了一个方法。函数定义代码不一定非得定义在类中：也可以将一个函数对象赋值给类中的一个局部变量。例如： # Function defined outside the class def f1(self, x, y): return min(x, x+y) class C: f = f1 def g(self): return &#39;hello world&#39; h = g 现在 f、g 和 h 都是 C类中的函数对象，因此它们都是 C 的实例的方法 —— h 完全等同于 g 。请注意，这种做法通常只会使阅读程序的人产生困惑。 方法可以通过使用 self 参数的方法属性，调用其他方法： class Bag: def __init__(self): self.data = [] def add(self, x): self.data.append(x) def addtwice(self, x): self.add(x) self.add(x) 方法可以像普通函数那样引用全局命名。与方法关联的全局作用域是包含这个方法的定义的模块（类）。（类本身永远不会作为全局作用域使用） 9.9 类的继承 面向对象的编程带来的主要好处之一是代码的重用，实现这种重用的方法之一是通过继承机制。 通过继承创建的新类称为子类或派生类，被继承的类称为基类或父类。 class DerivedClassName(BaseClassName): &lt;statement-1&gt; ... &lt;statement-N&gt; 在python中继承中的一些特点： 如果在子类中需要父类的构造方法就需要显示的调用父类的构造方法，或者不重写父类的构造方法。详细说明可查看：Python 子类继承父类构造函数说明。 在调用基类的方法时，需要加上基类的类名前缀，且需要带上 self 参数变量。区别在于类中调用普通函数时并不需要带上 self 参数。 Python 总是首先查找对应类型的方法，如果它不能在派生类中找到对应的方法，它才开始到基类中逐个查找。 如果在继承元组中列了一个以上的类，那么它就被称作”多重继承” 。 class Parent: parentAttr = 100 def __init__(self): print(&quot;Call the parent class constructor&quot;) def parentMethod(self): print(&#39;Call the parent class method&#39;) def setAttr(self, attr): Parent.parentAttr = attr def getAttr(self): print(&quot;Parent class attribute :&quot;, Parent.parentAttr) class Child(Parent): def __init__(self): print(&quot;Call subclass constructor&quot;) def childMethod(self): print(&#39;Call subclass method&#39;) c = Child() ## Call subclass constructor c.childMethod() ## Call subclass method c.parentMethod() ## Call the parent class method c.setAttr(200) c.getAttr() ## Parent class attribute : 200 派生类定义的执行过程和基类是相同的。在解析属性的引用时，如果在类中找不到请求的属性，搜索会在基类中继续。如果基类本身是由别的类派生而来，这个规则会递归应用。 派生类的实例化没有什么特殊之处： DerivedClassName() 创建类的一个新的实例。方法的引用按如下规则解析： 搜索对应的类的属性，必要时沿基类链逐级搜索，如果找到了函数对象这个方法引用就是合法的。 Python 有两个用于检查继承的函数： issubclass() 布尔函数，判断一个类是另一个类的子类或者子孙类，语法：issubclass(sub, sup) isinstance(obj, Class)布尔函数，如果obj是Class类的实例对象或者是一个Class子类的实例对象则返回true。 派生类可以重写基类中的方法。 class Parent: def myMethod(self): print(&#39;Call parent class method&#39;) class Child(Parent): def myMethod(self): print(&#39;Call subclass method&#39;) c = Child() c.myMethod() ## Call subclass method 派生类中的覆盖方法可能是想要扩充而不是简单的替代基类中的重名方法。有一个简单的方法可以直接调用基类方法：只要调用 BaseClassName.methodname(self, arguments)。 9.10 私有变量 Python中并不存在所谓只能在对象内部才能访问的“私有”实例变量。然而，有一项大多数 Python 代码都遵循的习惯：带有一个下划线前缀的名称（例如_spam ）应被视为非公开的 API 的一部分（无论是函数、 方法还是数据成员）。 由于存在一种合理的类私有成员使用场景（例如为了避免名称与子类所定义名称的冲突），Python 对这种机制提供了简单的支持，即所谓“名称重整” （name mangling）。__spam 形式的任何标识符（前面至少两个下划线，后面至多一个下划线）将被替换为 _classname__spam，其中 classname 为去除了前缀下划线的当前类名称。这种替换不考虑标识符的句法位置，只要它出现在类的定义内就会进行。 名称重整有利于子类重写父类的方法而不会破坏类内部的方法调用 class Mapping: def __init__(self, iterable): self.items_list = [] self.__update(iterable) def update(self, iterable): for item in iterable: self.items_list.append(item) __update = update # private copy of original update() method class MappingSubclass(Mapping): def update(self, keys, values): # provides new signature for update() # but does not break __init__() for item in zip(keys, values): self.items_list.append(item) 9.11 元类 在Python中，类也是对象（Classes are objects）。 class ObjectCreator: pass 会在内存中创造一个名为ObjectCreator的类对象。这个类对象具备创造对象的能力，同时它本身也是一个对象。它可以被赋值给别的变量，可以被复制，可以给它添加属性，可以作为函数参数传递。 print(ObjectCreator) ## &lt;class &#39;__main__.ObjectCreator&#39;&gt; def echo(o): print(o) echo(ObjectCreator) ## &lt;class &#39;__main__.ObjectCreator&#39;&gt; hasattr(ObjectCreator, &#39;new_attr&#39;) ## False ObjectCreator.new_attr = &#39;foo&#39; hasattr(ObjectCreator, &#39;new_attr&#39;) ## True ObjectCreator.new_attr ## &#39;foo&#39; ObjectCreatorMirror = ObjectCreator print(ObjectCreatorMirror()) ## &lt;__main__.ObjectCreator object at 0x0000000029C28130&gt; 因为类是对象，所以你可以想对象一样动态地创建它们。 def choose_class(name): if name == &quot;foo&quot;: class Foo: pass return Foo else: class Bar: pass return Bar myclass = choose_class(&#39;foo&#39;) print(myclass) ## &lt;class &#39;__main__.choose_class.&lt;locals&gt;.Foo&#39;&gt; print(myclass()) ## &lt;__main__.choose_class.&lt;locals&gt;.Foo object at 0x0000000029C272E0&gt; 因为类是对象，所以肯定可以由某些东西来创建。一种是使用关键词class，另一种是使用type函数手动创建。type函数常见的作用是查看对象的类型（type）。 type(1) ## &lt;class &#39;int&#39;&gt; type(&#39;1&#39;) ## &lt;class &#39;str&#39;&gt; type(ObjectCreator) ## &lt;class &#39;type&#39;&gt; type(ObjectCreator()) ## &lt;class &#39;__main__.ObjectCreator&#39;&gt; type可以按照以下方式定义类： type(name of the class, tuple of the parent class (for inheritance, can be empty), dictionary containing attributes names and values) 比如： MyShinyClass = type(&#39;MyShinyClass&#39;, (), {}) print(MyShinyClass) ## &lt;class &#39;__main__.MyShinyClass&#39;&gt; print(MyShinyClass()) ## &lt;__main__.MyShinyClass object at 0x0000000029C382E0&gt; Foo = type(&#39;Foo&#39;, (MyShinyClass,), {&#39;bar&#39;:True}) #inherit from MyShinyClass Foo.bar ## True 元类是创建类的类。type就是Python中的元类。 age = 35 age.__class__ ## &lt;class &#39;int&#39;&gt; name = &#39;bob&#39; name.__class__ ## &lt;class &#39;str&#39;&gt; def foo(): pass foo.__class__ ## &lt;class &#39;function&#39;&gt; class bar: pass bar.__class__ # then ## &lt;class &#39;type&#39;&gt; age.__class__.__class__ ## &lt;class &#39;type&#39;&gt; name.__class__.__class__ ## &lt;class &#39;type&#39;&gt; foo.__class__.__class__ ## &lt;class &#39;type&#39;&gt; 参考资料： Python官方教程 第九章：类 Python3 面向对象 Python面向对象 一篇文章搞懂Python中的面向对象编程 Python3 迭代器与生成器 一篇文章搞懂Python中的函数式编程 What are metaclasses in Python ? "],["functional.html", "Chapter 10 函数式编程", " Chapter 10 函数式编程 10.0.1 函数也是对象 由于Python函数都是对象，因此，在其他语言中较难表达的一些设计思想在Python中就要简单很多了。假设我们有下面这样一个字符串数组，希望对其进行一些数据清理工作并执行一堆转换： states = [&#39; Alabama &#39;, &#39;Georgia!&#39;, &#39;Georgia&#39;, &#39;georgia&#39;, &#39;FlOrIda&#39;, &#39;south carolina##&#39;, &#39;West virginia?&#39;] 不管是谁，只要处理过由用户提交的调查数据，就能明白这种乱七八糟的数据是怎么一回事。为了得到一组能用于分析工作的格式统一的字符串，需要做很多事情：去除空白符、删除各种标点符号、正确的大写格式等。做法之一是使用内建的字符串方法和正则表达式re模块： import re def clean_strings(strings): result = [] for value in strings: value = value.strip() value = re.sub(&#39;[!#?]&#39;, &#39;&#39;, value) value = value.title() result.append(value) return result 结果如下所示： clean_strings(states) ## [&#39;Alabama&#39;, &#39;Georgia&#39;, &#39;Georgia&#39;, &#39;Georgia&#39;, &#39;Florida&#39;, &#39;South Carolina&#39;, &#39;West Virginia&#39;] 其实还有另外一种不错的办法：将需要在一组给定字符串上执行的所有运算做成一个列表： def remove_punctuation(value): return re.sub(&#39;[!#?]&#39;, &#39;&#39;, value) clean_ops = [str.strip, remove_punctuation, str.title] def clean_strings(strings, ops): result = [] for value in strings: for function in ops: value = function(value) result.append(value) return result 然后我们就有了： clean_strings(states, clean_ops) ## [&#39;Alabama&#39;, &#39;Georgia&#39;, &#39;Georgia&#39;, &#39;Georgia&#39;, &#39;Florida&#39;, &#39;South Carolina&#39;, &#39;West Virginia&#39;] 这种多函数模式使你能在很高的层次上轻松修改字符串的转换方式。此时的clean_strings也更具可复用性！ 还可以将函数用作其他函数的参数，比如内置的map函数，它用于在一组数据上应用一个函数： for x in map(remove_punctuation, states): print(x) ## Alabama ## Georgia ## Georgia ## georgia ## FlOrIda ## south carolina ## West virginia 10.0.2 匿名（lambda）函数 Python支持一种被称为匿名的或lambda函数。它仅由单条语句组成，该语句的结果就是返回值。它是通过lambda关键字定义的，这个关键字没有别的含义，仅仅是说“我们正在声明的是一个匿名函数”。 def short_function(x): return x * 2 equiv_anon = lambda x: x * 2 本书其余部分一般将其称为lambda函数。它们在数据分析工作中非常方便，因为你会发现很多数据转换函数都以函数作为参数的。直接传入lambda函数比编写完整函数声明要少输入很多字（也更清晰），甚至比将lambda函数赋值给一个变量还要少输入很多字。看看下面这个简单得有些傻的例子： def apply_to_list(some_list, f): return [f(x) for x in some_list] ints = [4, 0, 1, 5, 6] apply_to_list(ints, lambda x: x * 2) ## [8, 0, 2, 10, 12] 虽然你可以直接编写[x *2 for x in ints]，但是这里我们可以非常轻松地传入一个自定义函数给apply_to_list函数。 再来看另外一个例子。假设有一组字符串，你想要根据各字符串不同字母的数量对其进行排序： strings = [&#39;foo&#39;, &#39;card&#39;, &#39;bar&#39;, &#39;aaaa&#39;, &#39;abab&#39;] 这里，我们可以传入一个lambda函数到列表的sort方法： strings.sort(key=lambda x: len(set(list(x)))) 笔记：lambda函数之所以会被称为匿名函数，与def声明的函数不同，原因之一就是这种函数对象本身是没有提供名称name属性。 10.0.3 柯里化：部分参数应用 柯里化（currying）是一个有趣的计算机科学术语，它指的是通过“部分参数应用”（partial argument application）从现有函数派生出新函数的技术。例如，假设我们有一个执行两数相加的简单函数： def add_numbers(x, y): return x + y 通过这个函数，我们可以派生出一个新的只有一个参数的函数——add_five，它用于对其参数加5： add_five = lambda y: add_numbers(5, y) add_numbers的第二个参数称为“柯里化的”（curried）。这里没什么特别花哨的东西，因为我们其实就只是定义了一个可以调用现有函数的新函数而已。内置的functools模块可以用partial函数将此过程简化： from functools import partial add_five = partial(add_numbers, 5) 10.0.4 生成器 能以一种一致的方式对序列进行迭代是Python的一个重要特点。这是通过一种叫做迭代器协议（iterator protocol，它是一种使对象可迭代的通用方式）的方式实现的。迭代器是一种特殊对象，它可以在诸如for循环之类的上下文中向Python解释器输送对象。大部分能接受列表之类的对象的方法也都可以接受任何可迭代对象。比如min、max、sum等内置方法以及list、tuple等类型构造器。 生成器（generator）是构造新的可迭代对象的一种简单方式。一般的函数执行之后只会返回单个值，而生成器则是以延迟的方式返回一个值序列，即每返回一个值之后暂停，直到下一个值被请求时再继续。要创建一个生成器，只需将函数中的return替换为yeild即可： def squares(n=10): print(&#39;Generating squares from 1 to {0}&#39;.format(n ** 2)) for i in range(1, n + 1): yield i ** 2 调用该生成器时，没有任何代码会被立即执行： gen = squares() gen ## &lt;generator object squares at 0x0000000012807350&gt; 直到你从该生成器中请求元素时，它才会开始执行其代码： for x in gen: print(x, end=&#39; &#39;) ## Generating squares from 1 to 100 ## 1 4 9 16 25 36 49 64 81 100 另一种更简洁的构造生成器的方法是使用生成器表达式（generator expression）。这是一种类似于列表、字典、集合推导式的生成器，其创建方式为，把列表推导式两端的方括号改成圆括号： gen = (x ** 2 for x in range(100)) gen ## &lt;generator object &lt;genexpr&gt; at 0x0000000012807580&gt; 它跟下面这个冗长得多的生成器是完全等价的： def _make_gen(): for x in range(100): yield x ** 2 gen = _make_gen() 生成器表达式也可以取代列表推导式，作为函数参数： sum(x ** 2 for x in range(100)) ## 328350 dict((i, i **2) for i in range(5)) ## {0: 0, 1: 1, 2: 4, 3: 9, 4: 16} 10.0.5 itertools模块 标准库itertools模块中有一组用于许多常见数据算法的生成器。例如，groupby可以接受任何序列和一个函数。它根据函数的返回值对序列中的连续元素进行分组。下面是一个例子： import itertools first_letter = lambda x: x[0] names = [&#39;Alan&#39;, &#39;Adam&#39;, &#39;Wes&#39;, &#39;Will&#39;, &#39;Albert&#39;, &#39;Steven&#39;] for letter, names in itertools.groupby(names, first_letter): print(letter, list(names)) # names is a generator ## A [&#39;Alan&#39;, &#39;Adam&#39;] ## W [&#39;Wes&#39;, &#39;Will&#39;] ## A [&#39;Albert&#39;] ## S [&#39;Steven&#39;] 10.0.6 错误和异常处理 优雅地处理Python的错误和异常是构建健壮程序的重要部分。在数据分析中，许多函数函数只用于部分输入。例如，Python的float函数可以将字符串转换成浮点数，但输入有误时，有ValueError错误。假如想优雅地处理float的错误，让它返回输入值。我们可以写一个函数，在try/except中调用float： def attempt_float(x): try: return float(x) except: return x attempt_float((1,2)) ## (1, 2) 当float(x)抛出异常时，才会执行except的部分。你可能注意到float抛出的异常不仅是ValueError： In [202]: float((1, 2)) --------------------------------------------------------------------------- TypeError Traceback (most recent call last) &lt;ipython-input-202-842079ebb635&gt; in &lt;module&gt;() ----&gt; 1 float((1, 2)) TypeError: float() argument must be a string or a number, not &#39;tuple&#39; 你可能只想处理ValueError，TypeError错误（输入不是字符串或数值）可能是合理的bug。可以写一个异常类型： def attempt_float(x): try: return float(x) except ValueError: return x 可以用元组包含多个异常： def attempt_float(x): try: return float(x) except (TypeError, ValueError): return x 某些情况下，你可能不想抑制异常，你想无论try部分的代码是否成功，都执行一段代码。可以使用finally： f = open(path, &#39;w&#39;) try: write_to_file(f) finally: f.close() "],["specialized-data-types.html", "Chapter 11 专门数据类型 11.1 日期和时间", " Chapter 11 专门数据类型 11.1 日期和时间 Python内建的datetime模块提供了datetime、date和time类型。datetime类型结合了date和time，是最常使用的： from datetime import datetime, date, time dt = datetime(2011, 10, 29, 20, 30, 21) dt.day ## 29 dt.date() ## datetime.date(2011, 10, 29) dt.time() ## datetime.time(20, 30, 21) strftime方法可以将datetime格式化为字符串： dt.strftime(&#39;%m/%d/%Y %H:%M&#39;) ## &#39;10/29/2011 20:30&#39; 类型 说明 %Y 四位数字的年 %y 两位数字的年 %m 两位数字的月[01，12] %d 两位数字的天[01，31] %H 小时（24小时制）[00，23] %l 小时（12小时制）[01，12] %M 两位数字的分[00，59] %5 秒[0，61]（60、61表示闰秒） %w 整数的周几[0（周日），6] %U 第几周[00，53]；周日当作一周的开始，第一个周日前面的天数作为”week 0” %W 第几周[00，53]；周一当作一周的开始，第一个周一前面的天数作为”week 0” %z UTC时区偏移量为+HHMM或-HHMM；不知道时区则为空 %F 表示%Y-%m-%d（即2012-4-18） %D 表示%m/%d/%y（即04/18/12） "],["title.html", "Chapter 12 Title 12.1 One", " Chapter 12 Title 12.1 One "],["applied-skills.html", "Chapter 13 实用技能", " Chapter 13 实用技能 13.0.1 文件和操作系统 13.0.1.1 文件的读写和关闭 f=open(&#39;somefile.txt&#39;) f.readline()#表示读文件的一行 f.readlines()#表示把文件从头到尾都读出来，并保存为一个列表 #使用文件应该牢记关闭 f.close() #更推荐下面这种方法，因为它会自动帮你关闭文件 with open(r&#39;somefile.txt&#39;) as f: f.readlines() #写入 f.write()#表示把字符串写入 f.writelines()#表示把一个列表写入 13.0.1.2 os模块 os模块提供了一种方便的使用操作系统函数的方法。 import os #假设在当前的目录下有一个abc.txt #重命名文件 os.rename(&#39;abc.txt&#39;,&#39;a123.txt&#39;) #删除文件 if os.path.exists(&#39;a123.txt&#39;): os.remove(&#39;a123.txt&#39;) #文件路径的处理 #假设有一个文件路径：path=&#39;/users/Python/Data/info.txt&#39; print(os.path.dirname(path)) #分割文件名 print(os.path.basename(path)) #分割文件的后缀 print(os.path.split(path)) #(&#39;/users/Python/Data&#39;, &#39;info.txt&#39;) #创建目录 os.mkdir(&#39;test01&#39;)#在当前目录下创建一个test01目录 os.mkdir(&#39;test02&#39;)#在当前目录下创建一个test02目录 #最后先判断目录是否存在 if not os.path.exists(&#39;test01&#39;): os.mkdir(&#39;test01&#39;) #列出当前目录下的所有文件和文件夹 print os.listdir(&#39;.&#39;) print list(os.walk(&#39;.&#39;)) #返回当前的目录 print os.getcwd() #删除目录，目录不为空时会报错 os.rmdir(&#39;test02&#39;) #shutil模块可以删除非空目录 shutil.rmtree(&#39;test02&#39;) #判断是否为文件 print os.path.isfile(&#39;test01&#39;) #判断是否为目录 print os.path.isdir(&#39;test01&#39;) #判断文件或者目录是否存在 print os.path.exists(&#39;demo_file.py&#39;) 标准库中的os模块里提供了system()函数，可以执行操作系统命令。比如在windows中，系统命令 start D:\\a.txt 就是启动程序自动打开D盘根目录中的 a.txt 文件。所以在Python程序中执行 os.system('start D:/a.txt') 就可以自动打开记事本显示该文件。 "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
